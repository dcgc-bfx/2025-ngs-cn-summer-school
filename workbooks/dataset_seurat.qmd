---
title: "The Dataset and the Seurat object"
format: revealjs
---

- https://lmweber.org/OSTA/pages/seq-workflow-visium-hd.html

# Overview

- Learn the basics
- Then some spatial

# Preparation

## Loading libraries

We load some important libraries.

```{r}
#| message: false

# Libraries
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(magrittr)
library(future)

# Colours
#options(ggplot2.discrete.colour= c("red", "#af01ef"))


```

# Our dataset

First we have a look at the dataset we are using for this training.

## Overview

We use a mouse brain dataset from [10x Genomics](https://www.10xgenomics.com/):

-   Dataset was downloaded from [here](https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-brain-he)
-   Male C57BL/6 mouse, 8 weeks
-   Brain tissue block (FFPE)
-   Visium HD Spatial Gene Expression kit
-   Illumina NovaSeq 6000, \~300mio reads
-   Spaceranger was already run

The dataset is in the folder `datasets/visiumhd_mouse_brain` of the project directory. To download it again, run script `download.R` script that is also in the folder.

## Dataset files

Let us have a look at the dataset. These results are mostly informative:

-   `web_summary.html`: QC report in HTML format
-   `metrics_summary.csv`: QC report in CSV format
-   `cloupe_008um.cloupe`: Loupe file for visualizing the data in Loupe Browser
-   `spatial`: Folder containing the images
-   `molecule_info.h5`: File with information about reads and molecules (H5 format)
-   `feature_slice.h5`: File for high-performance data access of 2 µm bins

These results contain the input for our analysis:

-   `binned_outputs`: Folder containing results for different bin sizes
    -   `square_002um`: 2µm binned output
    -   `square_008um`: 8µm binned output
    -   `square_0016um`: 16µm binned output

By default, Spaceranger groups the data into square bins of 2, 8 and 16 µm - the resolution. However, these can be changed in the Spaceranger settings.

## Binned results

Let us have a look at `square_008um`. These results are mostly informative:

-   `analysis`: Folder containing Spaceranger analysis results
-   `cloupe.cloupe`: Loupe file for visualizing the data in Loupe Browser

These results contain the files for all bins under tissue. This is what we want to analyse:

-   `filtered_feature_bc_matrix` and `filtered_feature_bc_matrix.h5` : Counts per bin and gene as directory/H5 file
-   `spatial`: Folder containing the images and the positions of the bins on the tissue

Just for completeness, there are also results for all bins (tissue or no tissue):

-   `raw_feature_bc_matrix` and `raw_feature_bc_matrix.h5`: Counts as directory/H5 file

## Counts data

Let us have look at the `filtered_feature_bc_matrix` directory. It contains three files:

- The `barcodes.tsv.gz` file contains the names of the bins:

```{r}
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/barcodes.tsv.gz", header = FALSE, nrows = 5)
```

- The `features.tsv.gz` file contains the Ensembl id, symbols and types of genes:

```{r}
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/features.tsv.gz", header = FALSE, nrows = 5)
```

- The `matrix.mtx.gz` file contains the actual counts data:
```{r}
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/matrix.mtx.gz", skip = 2, nrows = 5, header = FALSE, sep = " ")
```

  - The first row contains the total number of genes, bins and counts.
  - All other rows contain the gene index (row in `features.tsv.gz`), bin index (row in `barcodes.tsv.gz`) and the count value.
  - Only non-zero counts are stored.

<!--
- Example: 
  - This dataset has 19,059 genes, 98,917 bins and 68,259,814 counts.
  - Row 2: Gene #**17** (Vxn) has in bin #**1** (s_016um_00052_00082-1) a count of **3**.
-->

# The Seurat object

The R package [Seurat](https://satijalab.org/seurat/) is a popular software for single-cell and spatial analysis. Alternatives are the R package [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) or the python [scanpy](https://squidpy.readthedocs.io/en/stable/) package.

## Import the data into Seurat

First we load our data for 8 and 16µm bins into an Seurat object.

```{r}
sc <- Load10X_Spatial("datasets/visiumhd_mouse_brain", bin.size = c(8, 16), assay = "RNA")
sc$orig.ident <- "brain"
Idents(sc) <- "brain"
```

Let us check what is in the Seurat object:

```{r}
sc
```

<!--
Oral exercise:
- How many assays are in the dataset?
- How many images are in the dataset?
- Why always two?
-->

## What is stored in the Seurat object

The Seurat object stores different components that are used for the analysis. The most important ones are:

-   bins and genes
-   assay data: gene expression, chromatin accessibility, surface proteins, ...
-   metadata for bins: cluster, sample, condition, ...
-   metadata for genes/features: id, name, type, description, ...
-   dimensionality reductions: PCA, UMAP, tSNE, ...
-   neighbors and graphs: for clustering
-   images: images as well as spatial coordinates (for different bin sizes)

## Bins and genes

We get the total number of genes and bins like this:

```{r}
dim(sc)
```

We can also list bins and genes that are stored in the object:

```{r}
Cells(sc) %>% head(5)
Features(sc) %>% head(5)
```

Note that sometimes the more general terms barcodes (bins/cells/nuclei/...) and features (genes/proteins/peaks/...) are used. We will stick to bins and genes for this workshop.

## Assay data

Assays store the actual data. We can list the available assays with the `Assays` function:

```{r}
Assays(sc)
```

An assay can be accessed with the `GetAssay` function or with the `[[]]` syntax:

```{r}
GetAssay(sc, assay = "RNA.008um")
sc[["RNA.008um"]]
```

We can also get the number of genes and bins for the assay like this:

```{r}
assay <- GetAssay(sc, assay = "RNA.008um")
dim(assay)
```

<!--
Oral exercise:
- How many bins/cells are in the assay?
- How many genes are in the assay?
-->

---

The assay object stores data in different layers:

-   `counts`: raw counts
-   `data`: normalized counts
-   `scale.data`: normalized counts, centered and scaled

We use the `GetAssayData` function to access the actual data:

```{r}
#| message: true
counts <- GetAssayData(sc, assay = "RNA.008um", layer = "counts")
counts[1:10, 1:10]
```

You will see many dots (zeros) and a few numbers representing the counts per gene per bin.

---

The Seurat object has a default/active assay. We can check it with the `DefaultAssay` function:

```{r}
DefaultAssay(sc)
```

We can also switch to another assay:

```{r}
DefaultAssay(sc) <- "RNA.016um"
DefaultAssay(sc)
```

For now, we use the assay `RNA.008um` for our analysis.

```{r}
DefaultAssay(sc) <- "RNA.008um"
DefaultAssay(sc)
```

Most of the Seurat functions use the default assay of the object but also provide an `assay=` argument to specify another assay.

## Bin metadata

Bin metadata stores additional information about bins such as sample or condition. It can be accessed using the `[[]]` syntax on the Seurat object:

```{r}
sc[[]] %>% head(5)
```

- `orig.ident`: the original identity of the bin
- `nCount_RNA.008um`: the number of counts in 8µm bins
- `nFeature_RNA.008um`: the number of genes in 8µm bins
...

Individual columns can be accessed using the `$` syntax on the Seurat object:

```{r}
sc$nCount_RNA.008um %>% head(3)
```

## Gene metadata

Gene metadata can be accessed using the `[[]]` syntax on an Seurat assay object:

```{r}
#| message: true

assay <- GetAssay(sc, assay = "RNA.008um")
assay[[]] %>% head(5)
```

There is currently no gene metadata for this Seurat assay object. 

If available, individual columns can be accessed using the `$` syntax on the Seurat assay object.

## Dimensionality reductions

We can list the available reductions with the `Reductions` function:

```{r}
Reductions(sc)
```

There are currently no reductions in this Seurat object. If available, a reduction can be accessed with the `Reductions` function or with the `[[]]` syntax.

```{r}
# Reductions(sc, slot = "pca")
# sc[["pca"]]
```

## Neighbors and graphs

We can list computed neighbors and graphs with the `Neighbors` and `Graphs` functions:

```{r}
Neighbors(sc)
Graphs(sc)
```

There are currently no neighbors or graphs in this Seurat object. If available, a neighbor or graph can be accessed with the `Neighbors` or `Graphs` function or with the `[[]]` syntax.

```{r}
# Neighbors(sc, slot = "RNA.nn")
# sc[["RNA.nn"]]

# Graphs(sc, slot = "RNA_nn")
# sc[["RNA_nn"]]
```

## Images

For spatial data, images are stored in the Seurat object. List the available images with the `Images` function:

```{r}
Images(sc)
```

There is an image for each assay and bin size. To access an image, we can use the `[[]]` syntax:

```{r}
sc[["slice1.008um"]]
```


## Plotting

We can already plot counts for genes in the `RNA.008um` assay as violin plots:

```{r}
VlnPlot(sc, features = c("Nrgn", "Igf2", "Hap1"), layer="counts", pt.size = 0) + NoLegend()
```

Note that the counts are still not normalized/transformed which makes it hard to interpret them.

---

We can also plot the counts of these genes in spatial context:

```{r}
SpatialFeaturePlot(sc, features = c("Nrgn", "Igf2", "Hap1"), slot = "counts")
```

---

Finally, we can also plot the counts for the `RNA.016um` assay:

```{r}
DefaultAssay(sc) <- "RNA.016um"
p1 <- VlnPlot(sc, features = c("Nrgn"), layer="counts", pt.size = 0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features = c("Nrgn"), slot = "counts")
DefaultAssay(sc) <- "RNA.008um"
p1 | p2
```



# Quality control

## Motivation

Quality control (QC) is used to identify and remove low-quality bins from the dataset before further analysis. 

Low-quality bins can be the result due to problems during reverse transcription, PCR amplification or library preparation. They can also be the result of cell damage during the experiment, e.g. when the tissue already contains a lot of dead cells.

These bins need to be removed prior to further analysis because they can negatively influence the downstream analyses. For example, problematic bins could show up as separate clusters and be misidentified as distinct cell types.

## QC metrics

Low-quality bins can be identified by a few metrics, including:

-  number of genes
-  number of counts
-  mitochondrial content

We plot these metrics as distribution and also in spatial context to get an idea of the sample quality and to identify thresholds for filtering.

TODO: SpotSweeper?

## Number of counts

First we plot the number of counts per bin.

```{r}
p1 = VlnPlot(sc, features="nCount_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="nCount_RNA.008um") + NoLegend()
p1 | p2

summary(sc$nCount_RNA.008um)
```

---

We identify low-quality bins with less than 30 and more than 2000 counts and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_counts = WhichCells(sc, 
                                   expression=nCount_RNA.008um < 30 | nCount_RNA.008um > 2000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_counts) + NoLegend()
```

## Number of genes

Secondly, we plot the number of genes per bin.

```{r}
p1 <- VlnPlot(sc, features="nFeature_RNA.008um", pt.size=0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features="nFeature_RNA.008um") + NoLegend()
p1 | p2

summary(sc$nFeature_RNA.008um)
```

---

We identify low-quality bins with less than 30 and more than 1000 genes and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_genes = WhichCells(sc,
                                  expression = nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000)

SpatialDimPlot(sc, cells.highlight=filtered_bins_genes) + NoLegend()
```

## Mitochondrial content

Finally we calculate and plot the mitochondrial content per bin.

```{r}
sc = PercentageFeatureSet(sc, pattern="^mt-", col.name="pMito_RNA.008um") 

p1 = VlnPlot(sc, features="pMito_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="pMito_RNA.008um") + NoLegend()
p1 | p2
```

---

We identify low-quality bins with more than 30% mitochondrial content and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_mito = WhichCells(sc,
                                  expression = pMito_RNA.008um > 30)
SpatialDimPlot(sc, cells.highlight=filtered_bins_mito) + NoLegend()
```

## Filtering of bins

Finally, when we have good thresholds, we can filter the dataset. Here is the `RNA.008um` assay object before filtering:

```{r}
dim(sc[["RNA.008um"]])
```

We use the `subset` function to remove the low-quality bins and then print the assay object after the filtering:

```{r}
sc = subset(sc, nCount_RNA.008um < 30 | nCount_RNA.008um > 2000, invert=TRUE)
sc = subset(sc, nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000, invert=TRUE)
sc = subset(sc, pMito_RNA.008um > 30, invert=TRUE)
sc[["RNA.008um"]]
```

## Filtering of genes

Further we remove genes that are only expressed in a few bins. To do this, we first get the number of non-zero counts per row/gene for our `RNA.008um` assay.

```{r}
counts = GetAssayData(sc, layer="counts")
genes_expressed = rowSums(counts > 0)
head(genes_expressed, 5)
```

Let us quickly summarize these numbers. Most of the genes are expressed in at least 30 bins, on average in 4063 bins and maximum in 283994 bins.

```{r}
summary(genes_expressed)
```

We keep genes are expressed in at least 10 bins. This is a very low threshold and we can filter more strictly depending on the dataset:

```{r}
genes_expressed = genes_expressed[genes_expressed > 10]
length(genes_expressed)
```

Then, we remove the genes from the `RNA.008um` assay object using the `subset` function: 

```{r}
sc[["RNA.008um"]]
sc[["RNA.008um"]] = subset(sc[["RNA.008um"]], features=names(genes_expressed))
sc[["RNA.008um"]]
```

## Recommendations

- Determine filter threshold for each dataset individually (there are no universal thresholds)
- Set sample-specific filter criteria (samples may differ)
- Make sure to check the spatial distribution of filtered bins to avoid removing spatial patterns
- At the beginning, run a full analysis (until clustering) without filtering 
  - Low-quality bins often cluster together
  - Plot QC metrics per cluster and identify clusters without or with ambiguous cell type
  - Then adjust filtering criteria accordingly and repeat
- Advanced: use tools that include neighboring bins (e.g [SpotSweeper](https://github.com/MicTott/SpotSweeper))

# Preprocessing

Once we have removed low-quality bins, we can proceed with the preprocessing of the data: 

- normalization
- identification of variable genes
- centering and scaling of the variable genes
- creating a sketch assay
- dimensionality reduction based on the variable genes

## Normalization

Raw counts are influenced by the library size (sequencing depth of the bin) and therefore difficult to interpret. We run a library size-based normalization to remove this effect:

- Counts for each cell are divided by the total counts for that cell and multiplied by 10000
- These "counts per 10000" are then log-transformed using the natural logarithm (including a pseudocount of 1)

We use the `ScaleData` function to normalize the data. This creates a new layer in the assay object called `data` that contains the normalized counts:

```{r}
sc = NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000, verbose=TRUE)
sc[["RNA.008um"]]
```

This creates a new layer in the assay object called `data` that contains the normalized counts. We can inspect the normalized counts with the `GetAssayData` function:

```{r}
data = GetAssayData(sc, layer="data")
data[1:10, 1:10]
```

---

Alternatives:

XXX

## Highly-variable genes

Next we select a set of genes that is 'highly variable' (HVG) in expression across bins. These genes will be used for further downstream analyses such as dimensionality reduction and clustering because they are more informative than other genes.

We use the `FindVariableFeatures` function to identify the top 1000 HVGs:


```{r}
sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=2000, verbose=TRUE)
```

```{r}
top10 = VariableFeatures(sc) %>% head(10)
top10
```

```{r}
p = VariableFeaturePlot(sc, selection.method="vst")
p = LabelPoints(plot=p, points=top10, repel=TRUE)
p
```


## Data scaling

The next step is to center and scale the data. Different genes have different expression levels and highly-expressed genes would exhibit much stronger influence on the analysis. By centering and scaling, all genes will be on the same scale (mean 0 and standard deviation 1) which makes them comparable.

We use the `ScaleData` function to center and scale the data. This creates a new layer in the assay object called `scale.data` that contains the scaled counts:

```{r}
sc = ScaleData(sc, features=VariableFeatures(sc), verbose=TRUE)
GetAssay(sc, assay="RNA.008um")
```

Note that we only scale the variable genes because they are the one used for further analysis. We can inspect the scaled and normalized counts with the `GetAssayData` function:

```{r}
scale_data = GetAssayData(sc, layer="scale.data")
scale_data[1:5, 1:5]
```

## Creating a sketch assay

Since the original assay is very large, we will create a sketch assay. This is a 'subsampled' version of the original assay which preserves rare populations. We then perform clustering on this smaller assay and project the clusters back to the original assay.

Instead of simple subsampling, Seurat computes a 'leverage score' for each bin. This score reflects the magnitude of the bins contribution to the overall dataset and typically it is highest for rare populations. By taking into account this leverage score, we can subsample datasets while still preserving the biological complexity of the sample.

We use the SketchData function to create a sketch assay of 50,000 bins from the original `RNA.008um` assay:

```{r}
# we select 50,0000 cells and create a new 'sketch' assay
sc = SketchData(sc, ncells=50000, method="LeverageScore", sketched.assay="sketch")
sc
```

When we print the Seurat object, we see that the default is now the sketch assay. We can also check that it is indeed smaller:

```{r}
GetAssay(sc, assay="sketch")
```

It is already normalized but, as for the original assay, we need to identify variable genes and scale the data:

```{r}
sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=2000, verbose=TRUE)
sc = ScaleData(sc, features=VariableFeatures(sc), verbose=TRUE)
GetAssay(sc, assay="sketch")
```

Note: This step is optional but helps with large datasets.

Once that is done, we will run the next steps using the sketch assay.

## Dimensionality reduction

Last, we run an dimensionality reduction to convert the high-dimensional dataset into lower-dimensional one that can be easier analysed. We are using principle component analysis (PCA) which is a linear method and find the directions of maximum variance in the data and projects the data onto these directions. The resulting set of variables is called principle components (PCs).

We use the `RunPCA` function to calculate the top 50 principle components (PCs) for the data. This creates a new dimensionality reduction object called `pca`:

```{r}
sc = RunPCA(sc, features=VariableFeatures(sc), npcs=50, verbose=TRUE, seed.use=1)
Reductions(sc, slot="pca")
```

We have now converted the 16907 genes into 50 PCs. We can plot the PCA results with the `DimPlot` function:

```{r}
DimPlot(sc, reduction="pca", dims=c(1, 2))
```

Importantly, PCs are ordered by the amount of variance they explain, i.e., PC1 explain the most amount, PC2 the second-most, ... . Next we plot the variance explained by each PC with the `ElbowPlot` function as well as a scatter plot PC1 vs PC2:

```{r}
p1 = ElbowPlot(sc, ndims=50)
p2 = DimPlot(sc, reduction="pca", group.by="orig.ident", label=TRUE)
```

We see that the plot at some point reaches a plateau where additional PCs only explain small amounts of variance. This is the 'elbow' point and we use it to determine the number of PCs for further analysis. In addition, we can also have a look at which genes contribute the most to the PCs:

```{r}
VizDimLoadings(sc, dims=1:4, nfeatures=10, balanced=TRUE)
```

In this case, we will use the first 20 PCs for downstream analyses.

# Clustering and visualization

## Clustering of the sketched dataset

```{r}

sc = FindNeighbors(sc, reduction = "pca", dims = 1:20)
sc = FindClusters(sc, cluster.name = "seurat_cluster.sketched", resolution = 3)
sc = RunUMAP(sc, reduction = "pca", reduction.name = "umap.sketch", return.model = T, dims = 1:20)

```


#

