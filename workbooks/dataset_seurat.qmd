---
title: "ðŸ§¬ Spatial Transcriptomics Analysis"
format: html
---

# Welcome to the NGS-CN Summer School on Spatial Transcriptomics Analysis!

Spatial transcriptomics allows us to measure gene expression across tissue sections while preserving spatial information, helping us understand not just **what** genes are active, but **where** they are active.

In this practical session, we will explore how to analyze spatial transcriptomics data using **R** and **RStudio**. Whether you are new to spatial data or already familiar with single-cell workflows, this guide will walk you through the essential steps.

Feel free to use your personal workbook to make notes, track your progress, and revisit it after this workshop.

## Setting up your R environment 

Before diving into the data, we need to load a few important R packages. These libraries will provide the tools we need for analysis and visualization.

```{r}
#| label: setup
#| message: false

library(Seurat)     # Main package for single-cell and spatial transcriptomics analysis
library(SeuratWrappers) # Add-ons for Seurat
library(patchwork)  # Helps combine multiple ggplot2 plots into one figure
library(tidyverse)  # Essential collection of R packages, including ggplot2, dplyr, magrittr
library(grid)       # For other plots
library(viridis)    # Our continuous colour palette

# Colours
cal_pal50 = c("#Fa1a8e", "#009B7D", "#ff9933", "#7083a4", "#ffce45", "#015e05", 
              "#fedf25", "#d2b48c", "#bb55e1", "#6ec5ab", "#5d57af", "#143341", 
              "#761445", "#d65b5a", "#94043a", "#e7a6cd", "#204519", "#87afd1", 
              "#9b9a9d", "#f95b70", "#83c874", "#808080", "#452b5b", "#ecb100", 
              "#f46124", "#525252", "#4c84a3", "#00bfff", "#01b4c6", "#174d79", 
              "#a6a0f2", "#76facc", "#8491be", "#a32a2f", "#1c8859", "#2cc012", 
              "#35782b", "#9c6755", "#3b3960", "#eeb0a1", "#3e1e13", "#0064c3", 
              "#d81e4a", "#74646c", "#f675da", "#ffce45", "#ec7014", "#e50000", 
              "#000000", "#a4527c", "#041859")   

# ggplot2 defaults
options(ggplot2.discrete.colour=cal_pal50)
options(ggplot2.discrete.fill=cal_pal50)
options(ggplot2.continuous.colour="viridis")
options(ggplot2.continuous.fill="viridis")
options(ggplot2.binned.colour="viridis")
options(ggplot2.binned.fill="viridis")

# Hook to measure the computation time of a chunk
# Activate with '#| timeit: true'. Deactivate with '#| timeit: null'
knitr::knit_hooks$set(timeit = function(before, options, envir) {
  if(before) {
    ## code to be run before a chunk
    tictoc::tic()
  } else {
    ## code to be run after a chunk
    elapsed = tictoc::toc()$toc
    print(paste0("Execution took ", elapsed, " seconds"))
  }
})
```

# Our dataset

In this section, we will introduce the dataset we are using for this training session.

## Dataset overview

We use a **mouse brain dataset** from [10x Genomics](https://www.10xgenomics.com/):   

* Source: Downloaded from [here](https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-brain-he)   
* Sample: Male C57BL/6 mouse, 8 weeks old   
* Tissue: Brain tissue block (Formalin-Fixed Paraffin-Embedded, or FFPE)   
* Platform: Visium HD Spatial Gene Expression kit   
* Sequencing: Illumina NovaSeq 6000, approximately 300 million reads   
* Processing: Space Ranger was already run to process the raw data   

The dataset is located in the `datasets/visiumhd_mouse_brain` directory within your project folder. If you need to download the dataset again, you can use the `datasets/download.R` script.

## Dataset files

The dataset includes several files and folders:

* `web_summary.html`: Quality control (QC) report in HTML format
* `metrics_summary.csv`: QC report in CSV format
* `cloupe_008um.cloupe`: Loupe file for visualizing the data in the Loupe Browser
* `molecule_info.h5`: H5 file with information about reads and molecules in the dataset
* `feature_slice.h5`: H5 file for high-performance data access of 2 Âµm bins
* `spatial`: Folder containing the tissue images
* `binned_outputs` Folder containing results organized by different bin sizes
   * `square_002um/`: Binned data with 2 Âµm resolution
   * `square_008um/`: Binned data with 8 Âµm resolution
   * `square_0016um/`: Binned data with 16 Âµm resolution

The folder `binned_outputs` is relevant for our analysis. Space Ranger defaults to grouping the data into square bins of 2 Âµm, 8 Âµm, and 16 Âµm, though these bin sizes can be modified in the Space Ranger settings.

## Focusing on `square_008um`

Let us focus on the `square_008um/` folder, which contains the binned results at 8 Âµm resolution. This folder includes:

* `analysis/`: Results from Space Ranger analysis
* `cloupe.cloupe`: Loupe file for visualizing the 8 Âµm binned data in Loupe Browser
* `raw_feature_bc_matrix/`: Raw counts for all bins (tissue or no tissue)
* `raw_feature_bc_matrix.h5`: As above, organized in H5 format
* `filtered_feature_bc_matrix/`: Counts for all bins located under tissue, per bin and gene
* `filtered_feature_bc_matrix.h5`: As above, organized in H5 format
* `spatial/`:  Folder with images and information about the spatial locations of the bins on the tissue

The key files for our analysis are located in `filtered_feature_bc_matrix`. 

## Counts data

Let us take a closer look at the `filtered_feature_bc_matrix/` directory, which includes three important files:

* `barcodes.tsv.gz`: Contains the names (or identifiers) for each of the bins in the dataset
* `features.tsv.gz` Contains essential information about the genes, including their Ensembl IDs, symbols and gene types
* `matrix.mtx.gz` Contains the actual counts data
   * The first row contains the total number of genes, bins and counts.
   * All other rows contain the gene index (row in `features.tsv.gz`), bin index (row in `barcodes.tsv.gz`) and the count value.
   * Only non-zero counts are stored.

```{r}
#| label: dataset_1

# barcodes.tsv.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/barcodes.tsv.gz", 
           header = FALSE, nrows = 5)

# features.tsv.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/features.tsv.gz", 
           header = FALSE, nrows = 5)

# matrix.mtx.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/matrix.mtx.gz", 
           skip = 2, nrows = 5, header = FALSE, sep = " ")
```

::: {.callout-tip}
### Example
This dataset has 19,059 genes, 98,917 bins and 68,259,814 counts.  
Row 2: Gene #**17** (Vxn) has in bin #**1** (s_016um_00052_00082-1) a count of **3**.
:::

# The Seurat object

The R package [Seurat](https://satijalab.org/seurat/) is a widely used tool for single-cell and spatial transcriptomics analysis. It allows researchers to work with complex biological data and perform tasks like dimensionality reduction, clustering, and visualization. 

Another popular option is the [scanpy](https://squidpy.readthedocs.io/en/stable/) package in Python. 

## Importing the data into Seurat

The first step in analyzing your data is to import it into Seurat. Here, we load data for both 8Âµm and 16Âµm bins into a Seurat object: 

```{r}
#| label: dataset_2

sc = Load10X_Spatial("datasets/visiumhd_mouse_brain", bin.size=c(8, 16), assay="RNA")
sc$orig.ident = "brain"
Idents(sc) = "brain"
```

Now, let us take a look at the Seurat object to understand its structure:

```{r}
#| label: dataset_3

sc
```

::: {.callout-note}
### Questions
How many assays are in the dataset?  
How many images are in the dataset?
Why always two?
:::

## What is stored in the Seurat object?

The Seurat object organizes data into different components. These components facilitate spatial transcriptomics analysis and are crucial for data interpretation. The key components include:

- **Bins and genes**: These represent the spatial units (bins) and the genes that are being measured
- **Assay data**: Contains the gene expression data, chromatin accessibility, surface proteins, etc.
- **Metadata for bins**: Information about each bin (e.g., sample type, condition)
- **Metadata for genes**: Includes gene IDs, names, types, and descriptions
- **Dimensionality reductions**: Methods like PCA, UMAP, and tSNE that are used to reduce the complexity of the data
- **Neighbors and graphs**: Information about the relatedness between bins
- **Images**: Spatial coordinates and image data for visualizing the tissue

## Bins and genes

We can retrieve the total number of genes and bins stored in the Seurat object like this:

```{r}
#| label: dataset_4

dim(sc)
```

We can also list the bins and genes contained in the Seurat object:

```{r}
#| label: dataset_5

Cells(sc) %>% head(5)
Features(sc) %>% head(5)
```

::: {.callout-tip}
### Nomenclature
Note that sometimes the term **bin** is also referred to as barcode, cell, nuclei.   
The term **gene** is also referred to as feature, protein, peak.   
We will stick to bins and genes for this workshop. 
:::

Furthermore, bins have a default identity which is used for plotting. It can be accessed with the `Idents` function:

```{r}
#| label: dataset_6

Idents(sc) %>% head(5)
```

## Assay data

Assays store the actual data, for example gene expression counts. We can list the available assays in the Seurat object:

```{r}
#| label: dataset_6

Assays(sc)
```

To access a specific assay, we use the `GetAssay` function or the `[[]]` syntax:

```{r}
#| label: dataset_7

GetAssay(sc, assay="RNA.008um")
sc[["RNA.008um"]]
```

We can also check the number of genes and bins in a specific assay like this:

```{r}
#| label: dataset_8

assay = GetAssay(sc, assay="RNA.008um")
dim(assay)
```

::: {.callout-note}
### Questions
How many bins are in the assay?   
How many genes are in the assay?
:::

The assay object stores data in different **layers**:  

* `counts`: Raw counts for each gene in each bin  
* `data`: Normalized counts for better comparability across bins  
* `scale.data`: Scaled data for better comparability across genes  

We use the `GetAssayData` function to access the actual data:  

```{r}
#| label: dataset_9
#| message: true

counts = GetAssayData(sc, assay="RNA.008um", layer="counts")
counts[1:10, 1:10]
```

::: {.callout-note}
### Questions
What do you find special about this matrix?
:::

The Seurat object has a default/active assay that is used for most functions. To check the active assay, we can use:

```{r}
#| label: dataset_10

DefaultAssay(sc)
```

To change the active assay to another one, for example `"RNA.016um"`, use:

```{r}
#| label: dataset_11

DefaultAssay(sc) = "RNA.016um"
DefaultAssay(sc)
```

For this workshop, we will focus on the assay `"RNA.008um"` for our analysis:

```{r}
#| label: dataset_12

DefaultAssay(sc) = "RNA.008um"
DefaultAssay(sc)
```

::: {.callout-tip}
### Default assay
Most Seurat functions will automatically use the default assay, but you can always specify a different assay with the `assay=` argument.
:::

## Bin metadata

Bin metadata store additional information about each bin, such as the sample or condition. You can access this metadata using the `[[]]` syntax:

```{r}
#| label: dataset_13

sc[[]] %>% head(5)
```

For example, the `orig.ident` column stores the original identity of the bin, and the `nCount_RNA.008um` and `nFeature_RNA.008um` columns store the number of counts and genes for the 8Âµm bins.

You can access individual metadata columns like this:

```{r}
#| label: dataset_14

sc$nCount_RNA.008um %>% head(3)
```

## Gene metadata

Gene metadata can be accessed using the `[[]]` syntax on the Seurat assay object:

```{r}
#| label: dataset_15
#| message: true

assay <- GetAssay(sc, assay = "RNA.008um")
assay[[]] %>% head(5)
```

In this example, no gene metadata is available for the assay. If available, you can access individual columns using the `$` syntax.

## Dimensionality reductions

Dimensionality reductions (e.g., PCA, UMAP, tSNE) are essential for visualizing high-dimensional data in a lower-dimensional space. You can list available reductions with the `Reductions` function:

```{r}
#| label: dataset_16

Reductions(sc)
```

Currently, there are no reductions in the Seurat object. If they were present, you could access them using the `GetReduction` function or the `[[]]` syntax.

## Neighbors and graphs

To identify how the bins are related (e.g., for clustering), Seurat computes neighbors and graphs. You can list available neighbors and graphs using:

```{r}
#| label: dataset_17

Neighbors(sc)
Graphs(sc)
```

Currently, there are no computed neighbors or graphs. If available, you could access them with the `GetNeighbors` / `GetGraph` functions or the `[[]]` syntax.

## Images

For spatial data, images are stored in the Seurat object to visualize tissue sections and spatial coordinates. To list available images, use:

```{r}
#| label: dataset_18

Images(sc)
```

Each assay and bin size should have a corresponding image. You can access a specific image using the `[[]]` syntax:

```{r}
#| label: dataset_19

sc[["slice1.008um"]]
```

When we refer to the image in spatial transcriptomics, we usually mean the spatial coordinates associated with each bin. These coordinates tell us where each bin is located within the tissue section but not what the tissue looks like visually.

However, Seurat also allows us to view the underlying histological image that was used to derive these spatial coordinates. This can help us visually inspect the tissue morphology in parallel with gene expression patterns.

In this example, **Hematoxylin and eosin (H&E) staining** was used. H&E staining is a widely used technique in histology and pathology for visualizing the morphological features of tissues. Hematoxylin stains cell nuclei a blue to purple hue by binding to nucleic acids, highlighting areas rich in DNA and RNA. Eosin is an acidic dye that stains the cytoplasm and extracellular matrix in varying shades of pink to red, depending on the protein content and tissue composition. The contrast between the basophilic (blue-purple) and eosinophilic (pink-red) structures enables clear differentiation of cellular components and tissue architecture, aiding in diagnostic assessment and research.

Here is how we can visualize the raw tissue image grid along with the spatial:

```{r}
#| label: dataset_20
#| out-width: 5in
#| out-height: 5in

gridExtra::grid.arrange(GetImage(sc[["slice1.008um"]], method="grob"))
```

## Plotting

Now that we have the data in Seurat, we can start visualizing gene expression using plots.

### Violin plot for gene expression

We can create a **violin plot** to show the expression of specific genes (e.g., "Nrgn", "Igf2", "Hap1") in the RNA.008um assay:

```{r}
#| label: dataset_21

VlnPlot(sc, features = c("Nrgn", "Igf2", "Hap1"), layer="counts", pt.size = 0) + NoLegend()
```

Since the counts are raw and not normalized, interpreting them directly can be challenging.

### Spatial plot for gene expression

We can also visualize gene expression in a spatial context using a **spatial feature plot**:

```{r}
#| label: dataset_22

SpatialFeaturePlot(sc, features=c("Nrgn", "Igf2", "Hap1"), slot="counts")
```

::: {.callout-tip}
### Plot size and resolution matter
You may observe visual artefacts in the image. This can occur when the image is plotted at a relatively low resolution (e.g., 150 dpi) and subsequently viewed on a high-resolution display. To address this issue, consider increasing the resolution using the Quarto `dpi` option. Alternatively, reducing the figure size may also help mitigate the problem.
:::

### Comparison Between 8Âµm and 16Âµm Bins

Finally, we can plot the gene expression in the **RNA.016um assays**. This allows us to visualize how the data changes when comparing different bin sizes.

```{r}
#| label: dataset_23

DefaultAssay(sc) <- "RNA.016um"
p1 <- VlnPlot(sc, features = c("Nrgn"), layer="counts", pt.size = 0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features = c("Nrgn"), slot = "counts")
DefaultAssay(sc) <- "RNA.008um"
p1 | p2
```

# Quality control

## Why quality control?

In spatial transcriptomics (and any sequencing-based assay), not all bins are equally informative. Quality Control (QC) is used to identify and remove low-quality bins from the dataset before further analysis. 

**Low-quality bins** might be the result of:  

* Problems during reverse transcription, PCR amplification or library preparation  
* Cell damage during the experiment, e.g. when the tissue already contains a lot of dead or dying cells  
* Very few transcripts overall, e.g. in empty regions  
* Unusually high numbers of transcripts, possibly doublets or noise  

**Why does this matter?**  
Low-quality bins can distort the results. For instance, they might cluster separately and be falsely interpreted as novel biological states or cell types. Performing QC early helps ensure the reliability of downstream steps like normalization, clustering, and cell type annotation.

## QC metrics at a glance

We will use three common metrics to flag low-quality bins:

- **Number of counts (UMIs):** Measures total expression in a bin. Too low = empty; too high = potential artifacts.
- **Number of detected genes:** Captures the diversity of expression in a bin. Low gene counts might mean poor capture.
- **Mitochondrial gene content:** High levels often indicate stressed or dying cells.

These metrics will be assessed both statistically and spatially to get an idea of the sample quality and to identify thresholds for filtering.

## Number of Counts per Bin

The total number of UMIs (counts) per bin gives a sense of overall transcript abundance.

```{r}
#| label: qc_1

p1 = VlnPlot(sc, features="nCount_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="nCount_RNA.008um")
p1 | p2

summary(sc$nCount_RNA.008um)
```

Look for bins with very few or very many counts. Bins with <30 counts or >2000 counts are suspicious and flagged for removal. 

::: {.callout-tip}
### Bins flagged here should appear randomly across the tissue #####
If they form a distinct pattern, reconsider the threshold â€” you might be removing biologically relevant data.
:::

```{r}
#| label: qc_2

filtered_bins_counts = WhichCells(sc, expression=nCount_RNA.008um < 30 | nCount_RNA.008um > 2000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_counts, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

::: {.callout-note}
### Find your optimal threshold
Play around with the thresholds in R. Which threshold would you find best?
:::

## Number of Genes per Bin

This tells us how many genes are detected per bin â€” essentially a measure of complexity.

```{r}
#| label: qc_3

p1 <- VlnPlot(sc, features="nFeature_RNA.008um", pt.size=0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features="nFeature_RNA.008um")
p1 | p2

summary(sc$nFeature_RNA.008um)
```

```{r}
#| label: qc_4

filtered_bins_genes = WhichCells(sc, expression = nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_genes, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

## Mitochondrial content

Mitochondrial RNA (mtRNA) often increases when cells are stressed or dying. A high percentage is a red flag.

We identify mitochondrial genes using a prefix (^mt-) and calculate their percentage per bin:

```{r}
#| label: qc_5

sc = PercentageFeatureSet(sc, pattern="^mt-", col.name="pMito_RNA.008um") 

p1 = VlnPlot(sc, features="pMito_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="pMito_RNA.008um") + NoLegend()
p1 | p2
```

```{r}
#| label: qc_6

filtered_bins_mito = WhichCells(sc, expression = pMito_RNA.008um > 30)
SpatialDimPlot(sc, cells.highlight=filtered_bins_mito, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

## Filtering of bins

Once you have reviewed the metrics and decided on thresholds, remove poor-quality bins using subset():

Before filtering:

```{r}
#| label: qc_7

dim(sc[["RNA.008um"]])
```

Apply the filters:

```{r}
#| label: qc_8

sc = subset(sc, nCount_RNA.008um < 30 | nCount_RNA.008um > 2000, invert=TRUE)
sc = subset(sc, nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000, invert=TRUE)
sc = subset(sc, pMito_RNA.008um > 30, invert=TRUE)
sc[["RNA.008um"]]
```

## Filtering of genes

Genes expressed in only a few bins can add noise. First, we count how many bins each gene is detected in:

```{r}
#| label: qc_9

counts = GetAssayData(sc, layer="counts")
genes_expressed = rowSums(counts > 0)
head(genes_expressed, 5)
summary(genes_expressed)
```

Let us quickly summarize these numbers. Most of the genes are expressed in at least 30 bins, on average in 4063 bins and maximum in 283994 bins.

```{r}
#| label: qc_10

summary(genes_expressed)
```

Filter out genes expressed in â‰¤10 bins:

```{r}
#| label: qc_11

genes_expressed = genes_expressed[genes_expressed > 10]
length(genes_expressed)
```

Then subset the Seurat object:

```{r}
#| label: qc_12

sc[["RNA.008um"]]
sc[["RNA.008um"]] = subset(sc[["RNA.008um"]], features=names(genes_expressed))
sc[["RNA.008um"]]
```

::: {.callout-tip}
### Best practices
* Avoid "one-size-fits-all" thresholds; adjust based on sample type, bin size, and sequencing depth
* Make sure to check the spatial distribution of filtered bins to avoid removing spatial patterns
* At the beginning, run a full analysis (until clustering) without filtering 
  * Low-quality bins often cluster together
  * Plot QC metrics per cluster and identify clusters without or with ambiguous cell type
  * Then adjust filtering criteria accordingly and repeat
* Advanced: use tools that include neighboring bins (e.g [SpotSweeper](https://github.com/MicTott/SpotSweeper))
:::

::: {.callout-note}
### Questions  
What might cause unusually high count bins?  
Why might mitochondrial content be misleading in some tissues (e.g., muscle or brain)?  
What are the trade-offs of stricter vs. more lenient filtering?  
:::

# Preprocessing

After removing low-quality bins, we now prepare the dataset for downstream analysis. This **preprocessing pipeline** includes:

1. Normalization of raw counts
2. Identification of highly variable genes (HVGs)
3. Centering and scaling of those HVGs
4. Optional sketching of the dataset for speed (HVGs)
5. Dimensionality reduction (PCA) based on the HVGs

Each step ensures that only informative, reliable data is passed into clustering and annotation workflows.

## Normalization

Raw counts vary widely across bins due to differences in sequencing depth (library size). To make counts **comparable across bins**, we perform normalization.

Note that normalization methods for spatial data are still being developed and evaluated. For this workshop, we apply log-normalization. 

**How does it work?**  

* Per cell, the count for each gene is divided by the total count for that cell, and then multiplied by 10,000  
* These "counts per 10,000" are then log-transformed using the natural logarithm (with a pseudocount of 1)  

This is implemented in Seurat with `NormalizeData()`:

```{r}
#| label: preprocessing_1

sc = NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000)
sc[["RNA.008um"]]
```

This creates a new layer in the assay object called `data` that contains the normalized counts. You can inspect the normalized values like so:

```{r}
#| label: preprocessing_2

data = GetAssayData(sc, layer="data")
data[1:10, 1:10]
```

## Identifying Highly Variable Genes (HVGs)

Not all genes are equally informative. Experience shows that 1,000-3,000 genes with the highest bin-to-bin variation are often sufficient to describe the global structure of a dataset. 

Highly variable genes are typically the genes that show strong variation across bins and are more likely to distinguish biological states. Housekeeping genes with similar expression profiles across all bins, or genes with minor expression differences, might add random noise and mask relevant changes during downstream analysis. 

Here, we determine the top 1000 HVGs: 

```{r}
#| label: preprocessing_3

sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=1000)
```

Note that 1,000 HGVs represents the lower end of the possible range. However, for demonstration purposes and to save memory, we use 1,000 in this example.

Get the top 10 HVGs and plot them:

```{r}
#| label: preprocessing_4

top10 = VariableFeatures(sc) %>% head(10)
top10

p = VariableFeaturePlot(sc, selection.method="vst")
p = LabelPoints(plot=p, points=top10, repel=TRUE)
p
```

## Data scaling

Gene expression ranges vary; some genes have inherently higher values. Centering and scaling ensures each gene contributes equally during the analysis. By centering (mean expression of 0) and scaling (standard deviation of 1), all genes will be on the same scale which makes them comparable. 

We use the `ScaleData` function to center and scale the HVGs:

```{r}
#| label: preprocessing_5

sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="RNA.008um")
```

This creates a new layer in the assay object called `scale.data` that contains the scaled counts:

```{r}
#| label: preprocessing_6

scale_data = GetAssayData(sc, layer="scale.data")
scale_data[1:5, 1:5]
```

## Creating a sketch assay

Large datasets can slow down clustering and UMAP. A sketch assay creates a reduced representation while preserving rare cell populations.

Instead of random sampling, Seurat uses a leverage score to keep influential or rare bins. We sketch 50,000 bins:

```{r}
#| label: preprocessing_7

sc = SketchData(sc, ncells=50000, method="LeverageScore", sketched.assay="sketch", features=VariableFeatures(sc))
sc
```

When we print the Seurat object, we see that the default is now the sketch assay. We can also check that it is indeed smaller:

```{r}
#| label: preprocessing_8

GetAssay(sc, assay="sketch")
```

Repeat HVG selection and scaling for the sketch:

```{r}
#| label: preprocessing_9

sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=1000)
sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="sketch")
```

::: {.callout-tip}
### Tip
Sketching is ideal for exploration on (very) large datasets. If your computing machine is super powerful or your dataset reasonably small, you might not need it. 
:::

## Dimensionality reduction

With ~20,000 genes, the data is too high-dimensional for visualization or clustering. At this point of the analysis, we have already reduced the dimensionality of the dataset to 1,000 HVGs. The biological manifold however can be described by far fewer dimensions than the number of (variable) genes, since expression profiles of different genes are correlated if they are involved in the same biological process. 

We use Principal Component Analysis (PCA) to reduce the dimensionality. PCA finds new axes (PCs) that capture the most variance in the dataset, and projects the data onto these axes. The resulting meta-variables are called principal components (PCs).

We use the `RunPCA` function to calculate the top 50 principle components (PCs) for the data. This creates a new dimensionality reduction object called `pca.sketch`:

```{r}
#| label: preprocessing_10

sc = RunPCA(sc, reduction.name="pca.sketch", features=VariableFeatures(sc), npcs=50, nfeatures.print=5)
Reductions(sc, slot="pca.sketch")
```

Visualize first two PCs:

```{r}
#| label: preprocessing_11

DimPlot(sc, reduction="pca.sketch", dims=c(1, 2))
```

In PCA, genes with the largest variation between bins will have the biggest influence on the PCs. The first PC captures the greatest variance across the dataset. The next PC captures the greatest remaining amount of variance, and so on. This way, the top PCs are likely to represent the biological signal where multiple genes are affected by the same biological processes in a coordinated way. In contrast, random technical or biological noise that affects each gene independently are contained in later PCs. 

Downstream analysis can be restricted to the top PCs. We need to decide how many PCs we want to use for our analysis. The following elbow plot shows PCs ranked based on the variance they explain. 

Look for the "elbow" â€” a point where adding more PCs gives diminishing returns:

```{r}
#| label: preprocessing_12

ElbowPlot(sc, reduction="pca.sketch", ndims=50)
```

You can also check which genes contribute most to each PC:

```{r}
#| label: preprocessing_13

VizDimLoadings(sc, reduction="pca.sketch", dims=1:4, nfeatures=10, balanced=TRUE)
```

::: {.callout-tip}
## Learnings
Helpful YouTube video on PCA in the context of gene expression analysis is (here)[https://www.youtube.com/watch?v=FgakZw6K1QQ]
:::

::: {.callout-note}
### Question
How many PCs would you choose for further analysis? 
:::

# Clustering and visualization

In the following, we **cluster** spatial bins based on their gene expression profiles and use **UMAP** (Uniform Manifold Approximation and Projection) to visualise the results in two dimensions.

**Clustering** is typically done using unsupervised algorithms (e.g., Louvain or Leiden) that group bins based on similarities across the full gene expression space. This helps to identify regions within the tissue that share similar transcriptional signatures, which may correspond to distinct anatomical structures or functional states. 

**UMAP** is a dimensionality reduction technique that projects high-dimensional data into a lower-dimensional space, in this case 2D, to reveal underlying structure. In UMAP plots, each bin is shown as a point, allowing us to detect substructures or transitions within clusters, identify outliers or ambiguous regions, communicate findings visually and intuitively. 

Clusters are discrete groupings assigned algorithmically based on expression similarity; each bin belongs to exactly one cluster. UMAP clouds, in contrast, are continuous visual projections. While clusters often appear as distinct clouds in UMAP space, overlaps can occur, especially in biologically complex areas. UMAP may reveal gradual transitions or relationships that clustering alone cannot capture.

## Clustering of the sketched dataset

Seurat uses a graph-based approach for clustering. In short, Seurat first constructs a graph by identifying the k-nearest neighbors for each bin in the PCA space based on Euclidean distance (NN). It then builds a refined version of the neighbor graph by considering shared neighbors between bins (SNN). Finally, a clustering algorithm is applied to the graph to identify groups of similar bins. These groups are then considered distinct cell populations. 

We begin by creating a nearest-neighbor graph using the `FindNeighbors` function in Seurat. We use the first 30 PCs as input and set the number of nearest neighbors to 20:

```{r}
#| label: clustering_1

sc = FindNeighbors(sc, reduction="pca.sketch", dims=1:30, k.param=20)
Graphs(sc)
```

After constructing the nearest-neighbor graph, we apply the Leiden algorithm to perform the clustering. The Leiden algorithm is an improvement over the Louvain method and works by optimizing modularity. It groups bins into clusters such that bins within the same cluster are more connected to each other than to bins in other clusters.

We call the `FindClusters` function with `algorithm=4`, which tells Seurat to use the Leiden algorithm. We also need to specify the resolution parameter. This parameter controls the granularity of the clustering:

* Higher resolution values lead to more clusters  
* Lower resolution values lead to fewer clusters  

We will start with a resolution of 2, but this can be adjusted later depending on the number of clusters you wish to identify:

```{r}
#| label: clustering_2

sc = FindClusters(sc, resolution=2, algorithm="leiden")

# Save as extra metadata column
sc$seurat_clusters.sketch = sc$seurat_clusters
```

The clusters are saved as bin metadata column `seurat_clusters.sketch`. Let us summarise the clustering of the sketched dataset:

```{r}
#| label: clustering_3

table(sc$seurat_clusters.sketch)
```

Note that we can provide multiple resolution values to test different clustering resolutions.

::: {.callout-note}
## Assignment
Test different cluster resolutions and observe the number of clusters you receive. 
:::

## UMAP of the sketched dataset

Now, we move on to generating a UMAP plot, which provides a visual representation of the dataset in lower-dimensional space. This helps to visually identify groups of similar cells, making it easier to explore and interpret the data.

We run the `RunUMAP` function and use the first 30 PCs as input. This creates a new dimensionality reduction object called `umap.sketch`:

```{r}
#| label: clustering_4

sc = RunUMAP(sc, reduction="pca.sketch", reduction.name="umap.sketch", dims=1:30, return.model=TRUE)
```

Note that `umap.sketch` is now the default dimensionality reduction. We can color the clustering on the UMAP as well as in spatial context:

```{r}
#| label: clustering_5

p1 = DimPlot(sc, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sc, images="slice1.008um") + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```

Here we can nicely see that we only analysed a subsampled dataset.

## Analysing the full dataset

Once we have finished analyzing the sketched dataset, we can project the learned cluster labels, PCA, and UMAP from the sketch assay onto the entire dataset. This allows us to transfer the insights gained from the subsampled dataset to the full dataset, which may have additional complexity.

We use the `ProjectData` function to carry out this projection. Hereâ€™s the code to project the data from the sketch assay to the full dataset:

```{r}
#| label: clustering_6

sc = ProjectData(sc,
                 sketched.assay="sketch", assay="RNA.008um", 
                 sketched.reduction="pca.sketch", full.reduction="pca.008um", 
                 umap.model="umap.sketch",
                 refdata=list(seurat_clusters.008um="seurat_clusters.sketch"),
                 dims=1:30)

# Fix the category levels for bin metadata column seurat_clusters.008um and update the bin identities
sc$seurat_clusters.008um = factor(sc$seurat_clusters.008um, levels=levels(sc$seurat_clusters.sketch))
Idents(sc) = "seurat_clusters.008um"

# Rename UMAP from full.umap.sketch to umap.008um
umap = sc[["full.umap.sketch"]]
Key(umap) = "umap.008"
sc[["umap.008um"]] = umap
sc[["full.umap.sketch"]] = NULL

# Set default assay back to RNA.008um
DefaultAssay(sc) = "RNA.008um"
gc()
```

The Seurat object now contains a full PCA (`pca.008um`), a full UMAP (`umap.008um`) and a full clustering (`seurat_clusters.008um`). We color the clusters of the full dataset on the UMAP as well as in spatial context:

```{r}
#| label: clustering_7

p1 = DimPlot(sc, reduction="umap.008um", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sc) + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```

When dealing with many clusters, some of which may be spatially restricted while others are not, it can be challenging to interpret their spatial distribution. In such cases, highlighting individual clusters can provide more clarity.

We can highlight specific clusters by using the `CellsByIdentities` function to select bins belonging to particular clusters. Here, we highlight clusters 16 and 8:

```{r}
#| label: clustering_8

cluster_bins = CellsByIdentities(sc, idents = c(16, 8))
cluster_bins[["NA"]] = NULL

SpatialDimPlot(sc, cells.highlight=cluster_bins, facet.highlight=TRUE, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

::: {.callout-tip}
## Recommendations

* Clustering  
  * Test different resolution values to find the best clustering solution for your data  
* UMAP  
  * UMAP "cloud" sizes and the distance between them may not be meaningful ast the method has a local notion of distance
  * Helpful explanation on YouTube (here)[https://www.youtube.com/watch?v=eN0wFzBA4Sc]
  * Helpful documentation and option to explore (here)[https://pair-code.github.io/understanding-umap/]  
* Keep in mind that this represents only a portion of the entire dataset, and the full dataset may reveal additional insights
* Take your time. In scRNA-seq analysis, this is perhaps the most time-consuming step of the basic analysis
:::

## What cell types correspond to the clusters? 

To identify the cell types corresponding to the clusters, we typically follow these steps:

* **Cluster marker genes**: Use differential gene expression analysis to find genes that are specifically expressed in each cluster. These can serve as markers for the corresponding cell types.
* **Known marker genes**: Visualize the expression of known cell-type markers on the UMAP to help associate clusters with specific cell types.
* **Mapping a reference dataset**: Use external datasets to map cell-type labels onto your data, enhancing the accuracy of your cell-type predictions.

By using these strategies, you can correlate the clusters with biological cell types and better understand the cell composition of your dataset.

## Cluster marker genes

One of the first steps in identifying the cell types of each cluster is to determine cluster-specific marker genes. These are genes that are significantly up- or downregulated in one cluster compared to others, which can be used to characterize the biological identity of the cells in each cluster.

You can use Seurat's FindMarkers function to identify differentially expressed genes between clusters:

...

...

## Plotting gene expression

To explore the results and visualize gene expression across different clusters, we can use various plotting functions.

A **violin plot** allows us to visualize the distribution of gene expression across clusters. For example, we can plot the expression of genes Acta2 and Apoe:

```{r}
#| label: clustering_9

VlnPlot(sc, features=c("Acta2", "Apoe"), pt.size=0, ncol=1) + NoLegend()
```

We can also visualize the gene expression directly on top of the **UMAP plot**. This will show the expression of genes such as Acta2 and Apoe across all cells in the low-dimensional UMAP space:

```{r}
#| label: clustering_10

FeaturePlot(sc, features=c("Acta2", "Apoe"), pt.size=0)
```

Since we are working with spatial data, you can visualize gene expression in the **spatial context**, showing where the genes are expressed on the tissue section:

```{r}
#| label: clustering_11

SpatialFeaturePlot(sc, features=c("Acta2", "Apoe"), pt.size=0)
```

A **dot plot** allows for the visualization of gene expression across multiple clusters for several genes. Here's an example where we plot the expression of 10 genes across clusters 1 to 10:

```{r}
#| label: clustering_12

DotPlot(sc, idents=1:10, 
        features=c("Hap1", "Nrgn", "Snap25", "Camk2n1", "Apoe", "Nap1l5", "Olfm1", "Penk", "Ptgds", "Pcp4"),
        scale=TRUE) + 
  scale_color_viridis() +
  theme(axis.text.x=element_text(angle=45, hjust=1))
```

For a more detailed look, we can create a **heatmap** to visualize the expression of the same genes in a subset of cells. This allows for a more focused analysis of gene expression patterns across specific clusters.

```{r}
#| label: clustering_13

set.seed(1)
cluster_bins = Cells(sc) %>% sample(10000)

DoHeatmap(sc, features=c("Hap1", "Nrgn", "Snap25", "Camk2n1", "Apoe", "Nap1l5", "Olfm1", "Penk", "Ptgds", "Pcp4"), 
          cells=cluster_bins,
          group.colors=cal_pal50) + 
  scale_fill_viridis() +
  guides(colour="none")
```

```{r}
# Remove since not used anymore and we need the memory.
rm(counts, data, scale_data, assay, umap)

# R will automatically clear the memory of freed objects whenever it needs more space.
# But in our experience it is sometimes better to explicitly tell R to do this - especially when working with big objects.
gc()
```

::: {.callout-note}
## Assignment
Visualize cluster marker genes and known marker genes on the UMAP and in spatial context, and identify at least one cell type from it. 
:::

# Spatial analysis

So far, we have learned the basics of analyzing spatial (and single-cell) datasets with Seurat and our workflow from above is a good starting point for an analysis.

However, it treats each bin independently and without considering its spatial context. Spatial analysis methods aim to improve this by incorporating the neighborhood of the bins. Several steps of our basic workflow could be adapted accordingly. Additionaly, 

## What is BANKSY?

(BANKSY)[https://github.com/prabhakarlab/Banksy] is a package for the analysis of spatial data. By including neighborhood information, it is able:

- improve noisy data
- distinguish between different cell types depending on the spatial context
- identify spatial domains

The amount of neighborhood information is controlled by the `lambda` parameter:
- With smaller values (e.g. 0.2) BANKSY focuses on the closest neighbors. This is used for cell typing.
- With larger values (e.g. 0.8) BANKSY includes more distant neighbors. This is used for domain finding.

BANKSY is an independent package that uses another framework for analysis. However, the `RunBanksy` function from the `SeuratWrappers` package allows us to run BANKSY on an Seurat object so that we do not have to learn all the details of the BANKSY package.

## Improve clustering with BANKSY

BANKSY can be used to as alternative to our default clustering strategy from before. We set `lambda` to a small value (0.2) so that BANKSY focuses only on the closest neighbors. Additionally, we set the number of neighbors (`k_geom`) to 15.

Note that this step can take a while and is very memory-intensive. 

```{r}
#| label: spatial_1

sc = RunBanksy(sc,
               assay="RNA.008um", assay_name="BANKSY.008um",
               features="variable",
               lambda=0.2, k_geom=15,
               verbose=TRUE)

# Set it as default
DefaultAssay(sc) = "BANKSY.008um"

gc()
```

Now we have created a new assay `BANKSY.008um` that contains the BANKSY results. It is also now the default assay. Important: Do not scale this assay as it will overwrite the BANKSY results.

```{r}
sc
```

We then use this assay to do PCA dimensionality reduction followed by clustering and UMAP. We will use the first 20 PCs and set the clustering resolution to 0.5. However this is just a starting point and you should try different values to find the best clustering for your data:

```{r}
sc = RunPCA(sc, reduction.name="banksy_pca.008um", features=rownames(sc[["BANKSY.008um"]]), npcs=15, nfeatures.print=5)
sc = FindNeighbors(sc, reduction="banksy_pca.008um", dims=1:15)
sc = FindClusters(sc, resolution=0.5, algorithm="leiden")
sc = RunUMAP(sc, reduction="banksy_pca.008um", reduction.name="banksy_umap.008um", dims=1:15, return.model=TRUE)

sc$banksy_clusters.008um = sc$seurat_clusters
DefaultAssay(sc) = "RNA.008um"
```

Here are our two analyses plotted side-by-side:

```{r}
p1 = DimPlot(sc, reduction="umap.008um", label=TRUE, group.by="seurat_clusters.008um") + NoLegend() + ggtitle("Seurat clustering")
p2 = DimPlot(sc, reduction="banksy_umap.008um", label=TRUE, group.by="banksy_clusters.008um") + NoLegend() + ggtitle("BANKSY clustering")
p1 | p2
```

The same comparison as spatial plots:

```{r}
p1 = SpatialDimPlot(sc, group.by="seurat_clusters.008um") + NoLegend() + ggtitle("Seurat") + scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sc, group.by="banksy_clusters.008um") + NoLegend() + ggtitle("BANKSY") + scale_fill_manual(values=cal_pal50)
p1 | p2
```

Note that the BANKSY analysis might not automatically be the better one. You should check the results and determine which analysis make biologically more sense.

## Find spatial domains with BANKSY

By tuning the `lambda` parameter, we can also focus on larger structures, i.e., spatial domains. With bigger `lambda` values and more neighbors, it will include more bins into the analysis. We set `lambda` to 0.8 and the number of neighbors (`k_geom`) to 50. 
Note that we fist delete the BANKSY assay from the previous analysis. This is not strictly necessary but it will save us some memory.

```{r}
DefaultAssay(sc) = "BANKSY.008um"
sc = RunBanksy(sc,
               assay="RNA.008um", assay_name="BANKSY.008um",
               features="variable",
               lambda=0.8, k_geom=50,
               verbose=TRUE)

# Set it as default
DefaultAssay(sc) = "BANKSY.008um"

gc()
```

As before, we run PCA, clustering and UMAP with 15 PCs and a clustering resolution of 0.5. Tune these parameters for your data:

```{r}
sc = RunPCA(sc, reduction.name="banksy_pca.008um", features=rownames(sc[["BANKSY.008um"]]), npcs=15, nfeatures.print=5)
sc = FindNeighbors(sc, reduction="banksy_pca.008um", dims=1:15)
sc = FindClusters(sc, resolution=0.5, algorithm="leiden")
sc$banksy_domains.008um = sc$seurat_clusters
```

Comparison here - why similar? Motivate to try diffewrent values


# Other useful resources

- [OSTA Visium HD Workflow](https://lmweber.org/OSTA/pages/seq-workflow-visium-hd.html)
- [Seurat Visium HD Analysis Vignette](https://satijalab.org/seurat/articles/visiumhd_analysis_vignette)
- [banksy](https://github.com/satijalab/seurat-wrappers/blob/master/docs/banksy.md)


