---
title: "üß¨ Spatial Transcriptomics Analysis"
format: html
---

# Welcome to the NGS-CN Summer School on Spatial Transcriptomics Analysis!

Spatial transcriptomics allows us to measure gene expression across tissue sections while preserving spatial information, helping us understand not just **what** genes are active, but **where** they are active.

In this practical session, we will explore how to analyze spatial transcriptomics data using **R** and **RStudio**. Whether you are new to spatial data or already familiar with single-cell workflows, this guide will walk you through the essential steps.

Feel free to use your personal workbook to make notes, track your progress, and revisit it after this Summer School.

## üì¶ Setting up your R environment 

Before diving into the data, we need to load a few important R packages. These libraries will provide the tools we need for analysis and visualization.

```{r}
#| label: setup
#| message: false

library(Seurat)     # Main package for single-cell and spatial transcriptomics analysis
library(patchwork)  # Helps combine multiple ggplot2 plots into one figure
library(tidyverse)  # Essential collection of R packages, including ggplot2, dplyr, magrittr

# Colours (for perhaps in the future :P)
our_colours = ggsci::pal_ucscgb()(50)
options(ggplot2.discrete.colour=our_colours)
options(ggplot2.discrete.fill=our_colours)
```

::: {.callout-note}
Pink enough? (https://www.artcraftblend.com/blogs/colors/shades-of-pink)
:::

::: {.callout-tip}
Pink enough? (https://www.artcraftblend.com/blogs/colors/shades-of-pink)
:::

::: {.callout-caution}
Pink enough? (https://www.artcraftblend.com/blogs/colors/shades-of-pink)
:::

::: {.callout-warning}
Pink enough? (https://www.artcraftblend.com/blogs/colors/shades-of-pink)
:::

::: {.callout-important}
Pink enough? (https://www.artcraftblend.com/blogs/colors/shades-of-pink)
:::

# Our Dataset

In this section, we will introduce the dataset we are using for this training session.

## üìä Dataset Overview

We use a **mouse brain dataset** from [10x Genomics](https://www.10xgenomics.com/):   

* Source: Downloaded from [here](https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-brain-he)   
* Sample: Male C57BL/6 mouse, 8 weeks old   
* Tissue: Brain tissue block (Formalin-Fixed Paraffin-Embedded, or FFPE)   
* Platform: Visium HD Spatial Gene Expression kit   
* Sequencing: Illumina NovaSeq 6000, approximately 300 million reads   
* Processing: Space Ranger was already run to process the raw data   

The dataset is located in the `datasets/visiumhd_mouse_brain` directory within your project folder. If you need to download the dataset again, you can use the `datasets/download.R` script.

## üìÇ Dataset files

The dataset includes several files and folders:

* `web_summary.html`: Quality control (QC) report in HTML format
* `metrics_summary.csv`: QC report in CSV format
* `cloupe_008um.cloupe`: Loupe file for visualizing the data in the Loupe Browser
* `molecule_info.h5`: H5 file with information about reads and molecules in the dataset
* `feature_slice.h5`: H5 file for high-performance data access of 2 ¬µm bins
* `spatial`: Folder containing the tissue images
* `binned_outputs` Folder containing results organized by different bin sizes
   * `square_002um/`: Binned data with 2 ¬µm resolution
   * `square_008um/`: Binned data with 8 ¬µm resolution
   * `square_0016um/`: Binned data with 16 ¬µm resolution

The folder `binned_outputs` is relevant for our analysis. Space Ranger defaults to grouping the data into square bins of 2 ¬µm, 8 ¬µm, and 16 ¬µm, though these bin sizes can be modified in the Space Ranger settings.

## üîç Focusing on `square_008um`

Let us focus on the `square_008um/` folder, which contains the binned results at 8 ¬µm resolution. This folder includes:

* `analysis/`: Results from Space Ranger analysis
* `cloupe.cloupe`: Loupe file for visualizing the 8 ¬µm binned data in Loupe Browser
* `raw_feature_bc_matrix/`: Raw counts for all bins (tissue or no tissue)
* `raw_feature_bc_matrix.h5`: As above, organized in H5 format
* `filtered_feature_bc_matrix/`: Counts for all bins located under tissue, per bin and gene
* `filtered_feature_bc_matrix.h5`: As above, organized in H5 format
* `spatial/`:  Folder with images and information about the spatial locations of the bins on the tissue

The key files for our analysis are located in `filtered_feature_bc_matrix`. 

## üìà Counts data

Let us take a closer look at the `filtered_feature_bc_matrix/` directory, which includes three important files:

* `barcodes.tsv.gz`: Contains the names (or identifiers) for each of the bins in the dataset
* `features.tsv.gz` Contains essential information about the genes, including their Ensembl IDs, symbols and gene types
* `matrix.mtx.gz` Contains the actual counts data
   * The first row contains the total number of genes, bins and counts.
   * All other rows contain the gene index (row in `features.tsv.gz`), bin index (row in `barcodes.tsv.gz`) and the count value.
   * Only non-zero counts are stored.

```{r}
# barcodes.tsv.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/barcodes.tsv.gz", header = FALSE, nrows = 5)

# features.tsv.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/features.tsv.gz", header = FALSE, nrows = 5)

# matrix.mtx.gz
read.delim("datasets/visiumhd_mouse_brain/binned_outputs/square_016um/filtered_feature_bc_matrix/matrix.mtx.gz", skip = 2, nrows = 5, header = FALSE, sep = " ")
```

<!--
- Example: 
  - This dataset has 19,059 genes, 98,917 bins and 68,259,814 counts.
  - Row 2: Gene #**17** (Vxn) has in bin #**1** (s_016um_00052_00082-1) a count of **3**.
-->

# The Seurat Object

The R package [Seurat](https://satijalab.org/seurat/) is a widely used tool for single-cell and spatial transcriptomics analysis. It allows researchers to work with complex biological data and perform tasks like dimensionality reduction, clustering, and visualization. 

Another popular option is the [scanpy](https://squidpy.readthedocs.io/en/stable/) package in Python. 

## Importing the Data into Seurat

The first step in analyzing your data is to import it into Seurat. Here, we load data for both 8¬µm and 16¬µm bins into a Seurat object: 

```{r}
sc = Load10X_Spatial("datasets/visiumhd_mouse_brain", bin.size=c(8, 16), assay="RNA")
sc$orig.ident = "brain"
Idents(sc) = "brain"
```

Now, let us take a look at the Seurat object to understand its structure:

```{r}
sc
```

<!--
Oral exercise:
- How many assays are in the dataset?
- How many images are in the dataset?
- Why always two?
-->

## What is Stored in the Seurat Object?

The Seurat object organizes data into different components. These components facilitate spatial transcriptomics analysis and are crucial for data interpretation. The key components include:

- **Bins and genes**: These represent the spatial units (bins) and the genes that are being measured
- **Assay data**: Contains the gene expression data, chromatin accessibility, surface proteins, etc.
- **Metadata for bins**: Information about each bin (e.g., sample type, condition)
- **Metadata for genes**: Includes gene IDs, names, types, and descriptions
- **Dimensionality reductions**: Methods like PCA, UMAP, and tSNE that are used to reduce the complexity of the data
- **Neighbors and graphs**: Information about the relatedness between bins
- **Images**: Spatial coordinates and image data for visualizing the tissue

## Bins and Genes

We can retrieve the total number of genes and bins stored in the Seurat object like this:

```{r}
dim(sc)
```

We can also list the bins and genes contained in the Seurat object:

```{r}
Cells(sc) %>% head(5)
Features(sc) %>% head(5)
```

Note that sometimes the term **bin** is referred to as barcode, cell, nuclei, and the term **gene** is referred to as feature, protein, peak. We will stick to bins and genes for this workshop. 

## Assay data

Assays store the actual data, for example gene expression counts. We can list the available assays in the Seurat object:

```{r}
Assays(sc)
```

To access a specific assay, we use the `GetAssay` function or the `[[]]` syntax:

```{r}
GetAssay(sc, assay="RNA.008um")
sc[["RNA.008um"]]
```

We can also check the number of genes and bins in a specific assay like this:

```{r}
assay = GetAssay(sc, assay="RNA.008um")
dim(assay)
```

<!--
Oral exercise:
- How many bins/cells are in the assay?
- How many genes are in the assay?
-->

### Assay Layers

The assay object stores data in different layers:
* `counts`: Raw counts for each gene in each bin
* `data`: Normalized counts for better comparability across bins
* `scale.data`: Scaled data for better comparabiliity across genes

We use the `GetAssayData` function to access the actual data:

```{r}
#| message: true

counts <- GetAssayData(sc, assay = "RNA.008um", layer = "counts")
counts[1:10, 1:10]
```

Here, you will see a sparse matrix with many zeros (representing no counts) and a few non-zero counts for gene expression.

The Seurat object has a default/active assay that is used for most functions. To check the active assay, we can use:

```{r}
DefaultAssay(sc)
```

To change the active assay to another one, for example `"RNA.016um"`, use:

```{r}
DefaultAssay(sc) = "RNA.016um"
DefaultAssay(sc)
```

For this workshop, we will focus on the assay `"RNA.008um"` for our analysis:

```{r}
DefaultAssay(sc) = "RNA.008um"
DefaultAssay(sc)
```

Most Seurat functions will automatically use the default assay, but you can always specify a different assay with the `assay=` argument.

## Bin Metadata

Bin metadata store additional information about each bin, such as the sample or condition. You can access this metadata using the `[[]]` syntax:

```{r}
sc[[]] %>% head(5)
```

For example, the `orig.ident` column stores the original identity of the bin, and the `nCount_RNA.008um` and `nFeature_RNA.008um` columns store the number of counts and genes for the 8¬µm bins.

You can access individual metadata columns like this:

```{r}
sc$nCount_RNA.008um %>% head(3)
```

## Gene Metadata

Gene metadata can be accessed using the `[[]]` syntax on the Seurat assay object:

```{r}
#| message: true

assay <- GetAssay(sc, assay = "RNA.008um")
assay[[]] %>% head(5)
```

In this example, no gene metadata is available for the assay. If available, you can access individual columns using the `$` syntax.

## Dimensionality reductions

We can list the available reductions with the `Reductions` function:

```{r}
Reductions(sc)
```

There are currently no reductions in this Seurat object. If available, a reduction can be accessed with the `Reductions` function or with the `[[]]` syntax.

```{r}
# Reductions(sc, slot = "pca")
# sc[["pca"]]
```

## Neighbors and graphs

We can list computed neighbors and graphs with the `Neighbors` and `Graphs` functions:

```{r}
Neighbors(sc)
Graphs(sc)
```

There are currently no neighbors or graphs in this Seurat object. If available, a neighbor or graph can be accessed with the `Neighbors` or `Graphs` function or with the `[[]]` syntax.

```{r}
# Neighbors(sc, slot = "RNA.nn")
# sc[["RNA.nn"]]

# Graphs(sc, slot = "RNA_nn")
# sc[["RNA_nn"]]
```

## Images

For spatial data, images are stored in the Seurat object. List the available images with the `Images` function:

```{r}
Images(sc)
```

There is an image for each assay and bin size. To access an image, we can use the `[[]]` syntax:

```{r}
sc[["slice1.008um"]]
```


## Plotting

We can already plot counts for genes in the `RNA.008um` assay as violin plots:

```{r}
VlnPlot(sc, features = c("Nrgn", "Igf2", "Hap1"), layer="counts", pt.size = 0) + NoLegend()
```

Note that the counts are still not normalized/transformed which makes it hard to interpret them.

---

We can also plot the counts of these genes in spatial context:

```{r}
SpatialFeaturePlot(sc, features = c("Nrgn", "Igf2", "Hap1"), slot = "counts")
```

---

Finally, we can also plot the counts for the `RNA.016um` assay:

```{r}
DefaultAssay(sc) <- "RNA.016um"
p1 <- VlnPlot(sc, features = c("Nrgn"), layer="counts", pt.size = 0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features = c("Nrgn"), slot = "counts")
DefaultAssay(sc) <- "RNA.008um"
p1 | p2
```

```{r}
1 + 1
knitr::knit_exit()
```


# Quality control

## Motivation

Quality control (QC) is used to identify and remove low-quality bins from the dataset before further analysis. 

Low-quality bins can be the result due to problems during reverse transcription, PCR amplification or library preparation. They can also be the result of cell damage during the experiment, e.g. when the tissue already contains a lot of dead cells.

These bins need to be removed prior to further analysis because they can negatively influence the downstream analyses. For example, problematic bins could show up as separate clusters and be misidentified as distinct cell types.

## QC metrics

Low-quality bins can be identified by a few metrics, including:

-  number of genes
-  number of counts
-  mitochondrial content

We plot these metrics as distribution and also in spatial context to get an idea of the sample quality and to identify thresholds for filtering.

TODO: SpotSweeper?

## Number of counts

First we plot the number of counts per bin.

```{r}
p1 = VlnPlot(sc, features="nCount_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="nCount_RNA.008um") + NoLegend()
p1 | p2

summary(sc$nCount_RNA.008um)
```

---

We identify low-quality bins with less than 30 and more than 2000 counts and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_counts = WhichCells(sc, 
                                   expression=nCount_RNA.008um < 30 | nCount_RNA.008um > 2000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_counts) + NoLegend()
```

## Number of genes

Secondly, we plot the number of genes per bin.

```{r}
p1 <- VlnPlot(sc, features="nFeature_RNA.008um", pt.size=0) + NoLegend()
p2 <- SpatialFeaturePlot(sc, features="nFeature_RNA.008um") + NoLegend()
p1 | p2

summary(sc$nFeature_RNA.008um)
```

---

We identify low-quality bins with less than 30 and more than 1000 genes and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_genes = WhichCells(sc,
                                  expression = nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000)

SpatialDimPlot(sc, cells.highlight=filtered_bins_genes) + NoLegend()
```

## Mitochondrial content

Finally we calculate and plot the mitochondrial content per bin.

```{r}
sc = PercentageFeatureSet(sc, pattern="^mt-", col.name="pMito_RNA.008um") 

p1 = VlnPlot(sc, features="pMito_RNA.008um", pt.size=0) + NoLegend()
p2 = SpatialFeaturePlot(sc, features="pMito_RNA.008um") + NoLegend()
p1 | p2
```

---

We identify low-quality bins with more than 30% mitochondrial content and highlight them in spatial context. We expect that the filtered bins should not follow spatial patterns.

```{r}
filtered_bins_mito = WhichCells(sc,
                                  expression = pMito_RNA.008um > 30)
SpatialDimPlot(sc, cells.highlight=filtered_bins_mito) + NoLegend()
```

## Filtering of bins

Finally, when we have good thresholds, we can filter the dataset. Here is the `RNA.008um` assay object before filtering:

```{r}
dim(sc[["RNA.008um"]])
```

We use the `subset` function to remove the low-quality bins and then print the assay object after the filtering:

```{r}
sc = subset(sc, nCount_RNA.008um < 30 | nCount_RNA.008um > 2000, invert=TRUE)
sc = subset(sc, nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000, invert=TRUE)
sc = subset(sc, pMito_RNA.008um > 30, invert=TRUE)
sc[["RNA.008um"]]
```

## Filtering of genes

Further we remove genes that are only expressed in a few bins. To do this, we first get the number of non-zero counts per row/gene for our `RNA.008um` assay.

```{r}
counts = GetAssayData(sc, layer="counts")
genes_expressed = rowSums(counts > 0)
head(genes_expressed, 5)
```

Let us quickly summarize these numbers. Most of the genes are expressed in at least 30 bins, on average in 4063 bins and maximum in 283994 bins.

```{r}
summary(genes_expressed)
```

We keep genes are expressed in at least 10 bins. This is a very low threshold and we can filter more strictly depending on the dataset:

```{r}
genes_expressed = genes_expressed[genes_expressed > 10]
length(genes_expressed)
```

Then, we remove the genes from the `RNA.008um` assay object using the `subset` function: 

```{r}
sc[["RNA.008um"]]
sc[["RNA.008um"]] = subset(sc[["RNA.008um"]], features=names(genes_expressed))
sc[["RNA.008um"]]
```

## Recommendations

- Determine filter threshold for each dataset individually (there are no universal thresholds)
- Set sample-specific filter criteria (samples may differ)
- Make sure to check the spatial distribution of filtered bins to avoid removing spatial patterns
- At the beginning, run a full analysis (until clustering) without filtering 
  - Low-quality bins often cluster together
  - Plot QC metrics per cluster and identify clusters without or with ambiguous cell type
  - Then adjust filtering criteria accordingly and repeat
- Advanced: use tools that include neighboring bins (e.g [SpotSweeper](https://github.com/MicTott/SpotSweeper))

# Preprocessing

Once we have removed low-quality bins, we can proceed with the preprocessing of the data: 

- normalization
- identification of variable genes
- centering and scaling of the variable genes
- creating a sketch assay
- dimensionality reduction based on the variable genes

## Normalization

Raw counts are influenced by the library size (sequencing depth of the bin) and therefore difficult to interpret. We run a library size-based normalization to remove this effect:

- Counts for each cell are divided by the total counts for that cell and multiplied by 10000
- These "counts per 10000" are then log-transformed using the natural logarithm (including a pseudocount of 1)

We use the `ScaleData` function to normalize the data. This creates a new layer in the assay object called `data` that contains the normalized counts:

```{r}
sc = NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000)
sc[["RNA.008um"]]
```

This creates a new layer in the assay object called `data` that contains the normalized counts. We can inspect the normalized counts with the `GetAssayData` function:

```{r}
data = GetAssayData(sc, layer="data")
data[1:10, 1:10]
```

---

Alternatives:

XXX

## Highly-variable genes

Next we select a set of genes that is 'highly variable' (HVG) in expression across bins. These genes will be used for further downstream analyses such as dimensionality reduction and clustering because they are more informative than other genes.

We use the `FindVariableFeatures` function to identify the top 2000 HVGs:


```{r}
sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=2000)
```

```{r}
top10 = VariableFeatures(sc) %>% head(10)
top10
```

```{r}
p = VariableFeaturePlot(sc, selection.method="vst")
p = LabelPoints(plot=p, points=top10, repel=TRUE)
p
```

## Data scaling

The next step is to center and scale the data. Different genes have different expression levels and highly-expressed genes would exhibit much stronger influence on the analysis. By centering and scaling, all genes will be on the same scale (mean 0 and standard deviation 1) which makes them comparable.

We use the `ScaleData` function to center and scale the data. This creates a new layer in the assay object called `scale.data` that contains the scaled counts:

```{r}
sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="RNA.008um")
```

Note that we only scale the variable genes because they are the one used for further analysis. We can inspect the scaled and normalized counts with the `GetAssayData` function:

```{r}
scale_data = GetAssayData(sc, layer="scale.data")
scale_data[1:5, 1:5]
```

## Creating a sketch assay

Since the original assay is very large, we will create a sketch assay. This is a 'subsampled' version of the original assay which preserves rare populations. We then perform clustering on this smaller assay and project the clusters back to the original assay.

Instead of simple subsampling, Seurat computes a 'leverage score' for each bin. This score reflects the magnitude of the bins contribution to the overall dataset and typically it is highest for rare populations. By taking into account this leverage score, we can subsample datasets while still preserving the biological complexity of the sample.

We use the SketchData function to create a sketch assay of 50,000 bins from the original `RNA.008um` assay:

```{r}
# we select 50,0000 cells and create a new 'sketch' assay
sc = SketchData(sc, ncells=50000, features=VariableFeatures(sc), method="LeverageScore", sketched.assay="sketch")
sc
```

When we print the Seurat object, we see that the default is now the sketch assay. We can also check that it is indeed smaller:

```{r}
GetAssay(sc, assay="sketch")
```

It is already normalized but, as for the original assay, we need to identify variable genes and scale the data:

```{r}
sc = FindVariableFeatures(sc, selection.method="vst", nfeatures=2000)
sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="sketch")
```

Note: This step is optional but helps with large datasets.

Once that is done, we will run the next steps using the sketch assay.

## Dimensionality reduction

Last, we run an dimensionality reduction to convert the high-dimensional dataset into lower-dimensional one that can be easier analysed. We are using principle component analysis (PCA) which is a linear method and find the directions of maximum variance in the data and projects the data onto these directions. The resulting set of variables is called principle components (PCs).

We use the `RunPCA` function to calculate the top 50 principle components (PCs) for the data. This creates a new dimensionality reduction object called `pca.sketch`:

```{r}
sc = RunPCA(sc, reduction.name="pca.sketch", features=VariableFeatures(sc), npcs=50)
Reductions(sc, slot="pca.sketch")
```

We have now converted the 16907 genes into 50 PCs. We can plot PC1 vs PC2 with the `DimPlot` function:

```{r}
DimPlot(sc, reduction="pca.sketch", dims=c(1, 2))
```

Importantly, PCs are ordered by the amount of variance they explain, i.e., PC1 explain the most amount, PC2 the second-most, ... . Next we plot the variance explained by each PC with the `ElbowPlot` function:

```{r}
ElbowPlot(sc, reduction="pca.sketch", ndims=50)
```

We see that the plot at some point reaches a plateau where additional PCs only explain small amounts of variance. This is the 'elbow' point and we use it to determine the number of PCs for further analysis. In addition, we can also have a look at which genes contribute the most to the PCs:

```{r}
VizDimLoadings(sc, reduction="pca.sketch", dims=1:4, nfeatures=10, balanced=TRUE)
```

In addition to the elbow plot, the gene contributions can also help with identifying the number of PCs. For this workshop, we will use the first 30 PCs for all downstream analyses.

# Clustering and visualization

- a
- b


## Clustering of the sketched dataset

For clustering, Seurat applies a graph-based approach. In short, Seurat first identifies for each bin its k nearest neighbors based on euclidean distance in PCA space. Using this neighborhood information, it then builds a nearest-neighbors graph (NN) and an improved version called shared nearest neighbor (SNN) graph.

We construct these graphs with the `FindNeighbors` function. We use the first 20 PCs as input and set the number of neighbors to 20:

```{r}
sc = FindNeighbors(sc, reduction="pca.sketch", dims=1:30, k.param=20)
Graphs(sc)
```

Seurat then splits the SNN graph into well-connected communities. It does this by iteratively grouping neighboring bins together while trying to optimize the modularity. Modularity is is a measure for connectivity in graphs and a high value indicates that the bins within a community are more connected to each other than to bins outside of the community. The final communities are called clusters.

We run the `FindClusters` function and use the Leiden algorithm instead of the default Louvain algorithm (`algorithm=4`). The resolution of the clustering can be controlled with the `resolution` parameter. Higher values lead to more clusters. We use `resolution=1` which is a good starting point:

```{r}
sc = FindClusters(sc, cluster.name="seurat_clusters.sketch", resolution=1, algorithm=4)
```

The clusters are saved as column in the bin metadata. Let us summarise the clustering of the sketched dataset:

```{r}
summary(sc$seurat_clusters.sketch)
```

We have clustered the sketched dataset into 21 clusters. Note that we can provide multiple resolution values to test different clustering resolutions.

## UMAP of the sketched dataset

Additionally, we run a dimensionality reduction method called Uniform Manifold Approximation and Projection (UMAP). UMAP is a non-linear method that embeds high-dimensional data into 2D while trying to preserve the local structure of the data. It is often used for visualization. However it should be avoided to draw biological conclusions from the UMAP only without actual clustering.

We run the `RunUMAP` function and use the first 20 PCs as input. This creates a new dimensionality reduction object called `umap.sketch`:

```{r}
sc = RunUMAP(sc, reduction="pca.sketch", reduction.name="umap.sketch", dims=1:30, return.model=TRUE)
```

Note that `umap.sketch` is now the default dimensionality reduction. We can plot the clustering on the UMAP as well as in spatial context:

```{r}
p1 = DimPlot(sc, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sc, images="slice1.008um") + NoLegend() + scale_fill_manual(values=our_colours)
p1 | p2
```

## Analysing the full dataset

We now use the `ProjectData`function to project the cluster labels, PCA and UMAP, that we learned from the 50,000 sketched cells, to the entire dataset:

```{r}
sc = ProjectData(sc,
                 sketched.assay="sketch", assay="RNA.008um", 
                 sketched.reduction="pca.sketch", full.reduction="pca.008um", 
                 umap.model="umap.sketch",
                 refdata=list(seurat_clusters="sc$seurat_clusters.sketch"),
                 dims=1:30)
```


# Other useful resources

- [OSTA Visium HD Workflow](https://lmweber.org/OSTA/pages/seq-workflow-visium-hd.html)
- [Seurat Visium HD Analysis Vignette](https://satijalab.org/seurat/articles/visiumhd_analysis_vignette)


