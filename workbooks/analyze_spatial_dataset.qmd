---
title: "🧬 Spatial Transcriptomics Analysis (part 2)"
format: html
---

# Welcome to the NGS-CN Summer School on Spatial Transcriptomics Analysis!

Spatial transcriptomics allows us to measure gene expression across tissue sections while preserving spatial information, helping us understand not just **what** genes are active, but **where** they are active.

In this practical session, we will explore how to analyze spatial transcriptomics data using **R** and **RStudio**. Whether you are new to spatial data or already familiar with single-cell workflows, this guide will walk you through the essential steps.

Feel free to use your personal workbook to make notes, track your progress, and revisit it after this workshop.

---

In this **second part**, we will cover key steps in the analysis workflow, including quality control, preprocessing, clustering and visualization, cluster annotation, spatial clustering, and integration with single-cell transcriptomics data.

## Setting up your R environment 

Before diving into the data, we need to load a few important R packages. These libraries will provide the tools we need for analysis and visualization.

```{r}
#| label: setup
#| message: false

library(Seurat)     # Main package for single-cell and spatial transcriptomics analysis
library(SeuratWrappers) # Add-ons for Seurat
library(patchwork)  # Helps combine multiple ggplot2 plots into one figure
library(tidyverse)  # Essential collection of R packages, including ggplot2, dplyr, magrittr
library(grid)       # For other plots
library(viridis)    # Our continuous color palette

# Colors
cal_pal50 = c("#Fa1a8e", "#009B7D", "#ff9933", "#7083a4", "#ffce45", "#015e05", 
              "#fedf25", "#d2b48c", "#bb55e1", "#6ec5ab", "#5d57af", "#143341", 
              "#761445", "#d65b5a", "#94043a", "#e7a6cd", "#204519", "#87afd1", 
              "#9b9a9d", "#f95b70", "#83c874", "#808080", "#452b5b", "#ecb100", 
              "#f46124", "#525252", "#4c84a3", "#00bfff", "#01b4c6", "#174d79", 
              "#a6a0f2", "#76facc", "#8491be", "#a32a2f", "#1c8859", "#2cc012", 
              "#35782b", "#9c6755", "#3b3960", "#eeb0a1", "#3e1e13", "#0064c3", 
              "#d81e4a", "#74646c", "#f675da", "#ffce45", "#ec7014", "#e50000", 
              "#000000", "#a4527c", "#041859")

# Set default colours for ggplot2
options(ggplot2.discrete.colour=cal_pal50)
options(ggplot2.discrete.fill=cal_pal50)
options(ggplot2.continuous.colour="viridis")
options(ggplot2.continuous.fill="viridis")
options(ggplot2.binned.colour="viridis")
options(ggplot2.binned.fill="viridis")
```

# Loading the dataset

In this session, we focus on the 8 µm bins and do not need load the 16 µm bins.

```{r}
#| label: dataset

sc = Load10X_Spatial("datasets/visiumhd_mouse_brain", bin.size=c(8), assay="RNA")
sc$orig.ident = "brain"
Idents(sc) = "brain"
```

# Quality control

## Why quality control?

In spatial transcriptomics (and any sequencing-based assay), not all bins are equally informative. Quality Control (QC) is used to identify and remove low-quality bins from the dataset before further analysis. 

**Low-quality bins** might be the result of:  

* Problems during reverse transcription, PCR amplification or library preparation  
* Cell damage during the experiment, e.g. when the tissue already contains a lot of dead or dying cells  
* Very few transcripts overall, e.g. in empty regions  
* Unusually high numbers of transcripts, possibly doublets or noise  

**Why does this matter?**  
Low-quality bins can distort the results. For instance, they might cluster separately and be falsely interpreted as novel biological states or cell types. Performing QC early helps ensure the reliability of downstream steps like normalization, clustering, and cell type annotation.

## QC metrics at a glance

We will use three common metrics to flag low-quality bins:

- **Number of counts (UMIs):** Measures total expression in a bin. Too low = empty; too high = potential artifacts.
- **Number of detected genes:** Captures the diversity of expression in a bin. Low gene counts might mean poor capture.
- **Mitochondrial gene content:** High levels often indicate stressed or dying cells.

These metrics will be assessed both statistically and spatially to get an idea of the sample quality and to identify thresholds for filtering.

## Number of Counts per Bin

The total number of UMIs (counts) per bin gives a sense of overall transcript abundance.

```{r}
#| label: qc_1

p1 = VlnPlot(sc, features="nCount_RNA.008um", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sc, features="nCount_RNA.008um")
p1 | p2

summary(sc$nCount_RNA.008um)
```

Look for bins with very few or very many counts. Bins with <30 counts or >2000 counts are suspicious and flagged for removal. 

::: {.callout-tip}
### Bins flagged here should appear randomly across the tissue #####
If they form a distinct pattern, reconsider the threshold — you might be removing biologically relevant data.
:::

```{r}
#| label: qc_2

filtered_bins_counts = WhichCells(sc, expression=nCount_RNA.008um < 30 | nCount_RNA.008um > 2000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_counts, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_counts), "bins filtered"))
```

::: {.callout-note}
### Find your optimal threshold
Play around with the thresholds in R. Which threshold would you find best?
:::

## Number of Genes per Bin

This tells us how many genes are detected per bin — essentially a measure of complexity.

```{r}
#| label: qc_3

p1 = VlnPlot(sc, features="nFeature_RNA.008um", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sc, features="nFeature_RNA.008um")
p1 | p2

summary(sc$nFeature_RNA.008um)
```

```{r}
#| label: qc_4

filtered_bins_genes = WhichCells(sc, expression = nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000)
SpatialDimPlot(sc, cells.highlight=filtered_bins_genes, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_genes), "bins filtered"))
```

## Mitochondrial content

Mitochondrial RNA (mtRNA) often increases when cells are stressed or dying. A high percentage is a red flag.

We identify mitochondrial genes using a prefix ("^mt-" means all genes starting with "mt-") and calculate their percentage per bin:

```{r}
#| label: qc_5

sc = PercentageFeatureSet(sc, pattern="^mt-", col.name="pMito_RNA.008um") 

p1 = VlnPlot(sc, features="pMito_RNA.008um", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sc, features="pMito_RNA.008um") + NoLegend()
p1 | p2
```

```{r}
#| label: qc_6

filtered_bins_mito = WhichCells(sc, expression=pMito_RNA.008um>30)
SpatialDimPlot(sc, cells.highlight=filtered_bins_mito, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_mito), "bins filtered"))
```

::: {.callout-note}
## Assignment
Calculate another QC metric `pMito_RNA.008um` that contains the percentage of counts from hemoglobin genes per bin. You can identify hemoglobin genes with the prefix "^Hb[ab]-".

Then plot it as violin plot and as spatial plot. Do many bins have hemoglobin?
:::

## Filtering of bins

Once you have reviewed the metrics and decided on thresholds, remove poor-quality bins using subset():

Before filtering:

```{r}
#| label: qc_7

dim(sc[["RNA.008um"]])
```

Apply the filters:

```{r}
#| label: qc_8

sc = subset(sc, nCount_RNA.008um < 30 | nCount_RNA.008um > 2000, invert=TRUE) %>% suppressWarnings()
sc = subset(sc, nFeature_RNA.008um < 30 | nFeature_RNA.008um > 1000, invert=TRUE) %>% suppressWarnings()
sc = subset(sc, pMito_RNA.008um > 30, invert=TRUE) %>% suppressWarnings()
sc[["RNA.008um"]]
```

## Filtering of genes

Genes expressed in only a few bins can add noise. First, we count how many bins each gene is detected in:

```{r}
#| label: qc_9

counts = GetAssayData(sc, layer="counts")
genes_expressed = rowSums(counts > 0)
head(genes_expressed, 5)
summary(genes_expressed)
```

Let us quickly summarize these numbers. Most of the genes are expressed in at least 30 bins, on average in 4063 bins and maximum in 283994 bins.

```{r}
#| label: qc_10

summary(genes_expressed)
```

Keep genes expressed in >10 bins:

```{r}
#| label: qc_11

genes_expressed = genes_expressed[genes_expressed > 10]
length(genes_expressed)
```

Then subset the Seurat object:

```{r}
#| label: qc_12

sc[["RNA.008um"]]
sc[["RNA.008um"]] = subset(sc[["RNA.008um"]], features=names(genes_expressed)) %>% suppressWarnings()
sc[["RNA.008um"]]
```

::: {.callout-tip}
### Best practices
* Avoid "one-size-fits-all" thresholds; adjust based on sample type, bin size, and sequencing depth
* Make sure to check the spatial distribution of filtered bins to avoid removing spatial patterns
* At the beginning, run a full analysis (until clustering) without filtering 
  * Low-quality bins often cluster together
  * Plot QC metrics per cluster and identify clusters without or with ambiguous cell type
  * Then adjust filtering criteria accordingly and repeat
* Advanced: use tools that include neighboring bins (e.g [SpotSweeper](https://github.com/MicTott/SpotSweeper))
:::

::: {.callout-note}
### Questions  
What might cause unusually high count bins?  
Why might mitochondrial content be misleading in some tissues (e.g., muscle or brain)?  
What are the trade-offs of stricter vs. more lenient filtering?  
:::

# Preprocessing

After removing low-quality bins, we now prepare the dataset for downstream analysis. This **preprocessing pipeline** includes:

1. Normalization of raw counts
2. Identification of highly variable genes (HVGs)
3. Centering and scaling of those HVGs
4. Optional sketching of the dataset for speed (HVGs)
5. Dimensionality reduction (PCA) based on the HVGs

Each step ensures that only informative, reliable data is passed into clustering and annotation workflows.

## Normalization

Raw counts vary widely across bins due to differences in sequencing depth (library size). To make counts **comparable across bins**, we perform normalization.

Note that normalization methods for spatial data are still being developed and evaluated. For this workshop, we apply log-normalization. 

**How does it work?**  

* Per cell, the count for each gene is divided by the total count for that cell, and then multiplied by 10,000  
* These "counts per 10,000" are then log-transformed using the natural logarithm (with a pseudocount of 1)  

This is implemented in Seurat with `NormalizeData()`:

```{r}
#| label: preprocessing_1

sc = NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000)
sc[["RNA.008um"]]
```

This creates a new layer in the assay object called `data` that contains the normalized counts. You can inspect the normalized values like so:

```{r}
#| label: preprocessing_2

data = GetAssayData(sc, layer="data")
data[1:10, 1:10]
```

## Identifying Highly Variable Genes (HVGs)

Not all genes are equally informative. Experience shows that 1,000-3,000 genes with the highest bin-to-bin variation are often sufficient to describe the global structure of a dataset. 

Highly variable genes are typically the genes that show strong variation across bins and are more likely to distinguish biological states. Housekeeping genes with similar expression profiles across all bins, or genes with minor expression differences, might add random noise and mask relevant changes during downstream analysis. 

Here, we determine the top 1000 HVGs: 

```{r}
#| label: preprocessing_3

sc = FindVariableFeatures(sc, nfeatures=1000)
```

Note that 1,000 HVGs represents the lower end of the possible range. However, for demonstration purposes and to save memory, we use 1,000 in this example.

Get the top 10 HVGs and plot them:

```{r}
#| label: preprocessing_4

top10 = VariableFeatures(sc) %>% head(10)
top10

p = VariableFeaturePlot(sc, selection.method="vst")
p = LabelPoints(plot=p, points=top10, repel=TRUE)
p
```

## Data scaling

Gene expression ranges vary; some genes have inherently higher values. Centering and scaling ensures each gene contributes equally during the analysis. By centering (mean expression of 0) and scaling (standard deviation of 1), all genes will be on the same scale which makes them comparable. 

We use the `ScaleData` function to center and scale the HVGs:

```{r}
#| label: preprocessing_5

sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="RNA.008um")
```

This creates a new layer in the assay object called `scale.data` that contains the scaled counts:

```{r}
#| label: preprocessing_6

scale_data = GetAssayData(sc, layer="scale.data")
scale_data[1:5, 1:5]
```

## Creating a sketch assay

Large datasets can slow down clustering and UMAP. A sketch assay creates a reduced representation while preserving rare cell populations.

Instead of random sampling, Seurat uses a leverage score to keep influential or rare bins. We sketch 50,000 bins:

```{r}
#| label: preprocessing_7

sc = SketchData(sc, ncells=50000, method="LeverageScore", sketched.assay="sketch", features=VariableFeatures(sc))
sc
```

When we print the Seurat object, we see that the default assay is now the sketch assay. We can also check that it is indeed smaller:

```{r}
#| label: preprocessing_8

GetAssay(sc, assay="sketch")
```

Repeat HVG selection and scaling for the sketch assay:

```{r}
#| label: preprocessing_9

sc = FindVariableFeatures(sc, nfeatures=1000)
sc = ScaleData(sc, features=VariableFeatures(sc))
GetAssay(sc, assay="sketch")
```

::: {.callout-tip}
### Tip
Sketching is ideal for exploration on (very) large datasets. If your computing machine is super powerful or your dataset reasonably small, you might not need it. 
:::

## Dimensionality reduction

With ~20,000 genes, the data is too high-dimensional for visualization or clustering. At this point of the analysis, we have already reduced the dimensionality of the dataset to 1,000 HVGs. The biological manifold however can be described by far fewer dimensions than the number of (variable) genes, since expression profiles of different genes are correlated if they are involved in the same biological process. 

We use Principal Component Analysis (PCA) to reduce the dimensionality. PCA finds new axes (PCs) that capture the most variance in the dataset, and projects the data onto these axes. The resulting meta-variables are called principal components (PCs).

We use the `RunPCA` function to calculate the top 50 principle components (PCs) for the data. This creates a new dimensionality reduction object called `pca.sketch`:

```{r}
#| label: preprocessing_10

sc = RunPCA(sc, reduction.name="pca.sketch", features=VariableFeatures(sc), npcs=50, nfeatures.print=5)
Reductions(sc, slot="pca.sketch")
```

Visualize first two PCs:

```{r}
#| label: preprocessing_11

DimPlot(sc, reduction="pca.sketch", dims=c(1, 2))
```

In PCA, genes with the largest variation between bins will have the biggest influence on the PCs. The first PC captures the greatest variance across the dataset. The next PC captures the greatest remaining amount of variance, and so on. This way, the top PCs are likely to represent the biological signal where multiple genes are affected by the same biological processes in a coordinated way. In contrast, random technical or biological noise that affects each gene independently are contained in later PCs. 

Downstream analysis can be restricted to the top PCs. We need to decide how many PCs we want to use for our analysis. The following elbow plot shows PCs ranked based on the variance they explain. 

Look for the "elbow" — a point where adding more PCs gives diminishing returns:

```{r}
#| label: preprocessing_12

ElbowPlot(sc, reduction="pca.sketch", ndims=50)
```

You can also check which genes contribute most to each PC:

```{r}
#| label: preprocessing_13

VizDimLoadings(sc, reduction="pca.sketch", dims=1:4, nfeatures=10, balanced=TRUE)
```

::: {.callout-tip}
## Learnings
Helpful YouTube video on PCA in the context of gene expression analysis is [here](https://www.youtube.com/watch?v=FgakZw6K1QQ)
:::

::: {.callout-note}
### Question
How many PCs would you choose for further analysis? 
:::

# Clustering and visualization

In the following, we **cluster** spatial bins based on their gene expression profiles and use **UMAP** (Uniform Manifold Approximation and Projection) to visualize the results in two dimensions.

**Clustering** is typically done using unsupervised algorithms (e.g., Louvain or Leiden) that group bins based on similarities across the full gene expression space. This helps to identify regions within the tissue that share similar transcriptional signatures, which may correspond to distinct anatomical structures or functional states. 

**UMAP** is a dimensionality reduction technique that projects high-dimensional data into a lower-dimensional space, in this case 2D, to reveal underlying structure. In UMAP plots, each bin is shown as a point, allowing us to detect substructures or transitions within clusters, identify outliers or ambiguous regions, communicate findings visually and intuitively. 

Clusters are discrete groupings assigned algorithmically based on expression similarity; each bin belongs to exactly one cluster. UMAP clouds, in contrast, are continuous visual projections. While clusters often appear as distinct clouds in UMAP space, overlaps can occur, especially in biologically complex areas. UMAP may reveal gradual transitions or relationships that clustering alone cannot capture.

## Clustering of the sketched dataset

Seurat uses a graph-based approach for clustering. In short, Seurat first constructs a graph by identifying the k-nearest neighbors for each bin in the PCA space based on Euclidean distance (NN). It then builds a refined version of the neighbor graph by considering shared neighbors between bins (SNN). Finally, a clustering algorithm is applied to the graph to identify groups of similar bins. These groups are then considered distinct cell populations. 

We begin by creating a nearest-neighbor graph using the `FindNeighbors` function in Seurat. We use the first 30 PCs as input and set the number of nearest neighbors to 20:

```{r}
#| label: clustering_1

sc = FindNeighbors(sc, reduction="pca.sketch", dims=1:30, k.param=20)
Graphs(sc)
```

After constructing the nearest-neighbor graph, we apply the Leiden algorithm to perform the clustering. The Leiden algorithm is an improvement over the Louvain method and works by optimizing modularity. It groups bins into clusters such that bins within the same cluster are more connected to each other than to bins in other clusters.

We call the `FindClusters` function with `algorithm="leiden"`, which tells Seurat to use the Leiden algorithm. We also need to specify the resolution parameter. This parameter controls the granularity of the clustering:

* Higher resolution values lead to more clusters  
* Lower resolution values lead to fewer clusters  

We will start with a resolution of 2, but this can be adjusted later depending on the number of clusters you wish to identify:

```{r}
#| label: clustering_2

# method="igraph" is nessessary for Seurat versions < 5.2
sc = FindClusters(sc, resolution=2, algorithm="leiden", random.seed=1, method="igraph")

# Save as extra metadata column
sc$seurat_clusters.sketch = sc$seurat_clusters
```

The clusters are saved as bin metadata column `seurat_clusters.sketch`. Let us summarize the clustering of the sketched dataset:

```{r}
#| label: clustering_3

table(sc$seurat_clusters.sketch)
```

Note that we can provide multiple resolution values to test different clustering resolutions.

::: {.callout-note}
## Assignment
Test different cluster resolutions and observe the number of clusters you receive. 
:::

## UMAP of the sketched dataset

Now, we move on to generating a UMAP plot, which provides a visual representation of the dataset in lower-dimensional space. This helps to visually identify groups of similar cells, making it easier to explore and interpret the data.

We run the `RunUMAP` function and use the first 30 PCs as input. This creates a new dimensionality reduction object called `umap.sketch`:

```{r}
#| label: clustering_4

# return.model is only needed when doing sketching
sc = RunUMAP(sc, reduction="pca.sketch", reduction.name="umap.sketch", dims=1:30, return.model=TRUE)
```

Note that `umap.sketch` is now the default dimensionality reduction. We can color the clustering on the UMAP as well as in spatial context:

```{r}
#| label: clustering_5
#| dpi: 75

p1 = DimPlot(sc, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sc, images="slice1.008um") + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```

Here we can clearly see that we only analysed a subsampled dataset.

::: {.callout-note}
## Assignment

Test different `n.neighbors` to find a good 2D representation of the dataset. Plot the old and new UMAP next to each other for comparison.
:::

```{r}
#| label: clustering_4_5_test
sc = RunUMAP(sc, reduction="pca.sketch", reduction.name="umap.sketch.test", dims=1:30, 
             n.neighbors=100)

p1 = DimPlot(sc, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = DimPlot(sc, reduction="umap.sketch.test", label=TRUE) + NoLegend()
p1 | p2
```

## Analysing the full dataset

Once we have finished analyzing the sketched dataset, we can project the learned cluster labels, PCA, and UMAP from the sketch assay onto the entire dataset. This allows us to transfer the insights gained from the subsampled dataset to the full dataset, which may have additional complexity.

We use the `ProjectData` function to carry out this projection. Here’s the code to project the data from the sketch assay to the full dataset:

```{r}
#| label: clustering_6

sc = ProjectData(sc,
                 sketched.assay="sketch", assay="RNA.008um", 
                 sketched.reduction="pca.sketch", full.reduction="pca.008um", 
                 umap.model="umap.sketch",
                 refdata=list(seurat_clusters.008um="seurat_clusters.sketch"),
                 dims=1:30)

# Fix the category levels for bin metadata column Seurat_clusters.008um and update the bin identities
sc$seurat_clusters.008um = factor(sc$seurat_clusters.008um, levels=levels(sc$seurat_clusters.sketch))
Idents(sc) = "seurat_clusters.008um"

# Rename UMAP from full.umap.sketch to umap.008um
umap = sc[["full.umap.sketch"]]
Key(umap) = "umap.008"
sc[["umap.008um"]] = umap
sc[["full.umap.sketch"]] = NULL

# Set default assay back to RNA.008um
DefaultAssay(sc) = "RNA.008um"
gc()
```

The Seurat object now contains a full PCA (`pca.008um`), a full UMAP (`umap.008um`) and a full clustering (`seurat_clusters.008um`). We color the clusters of the full dataset on the UMAP as well as in spatial context:

```{r}
#| label: clustering_7

p1 = DimPlot(sc, reduction="umap.008um", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sc) + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```

When dealing with many clusters, some of which may be spatially restricted while others are not, it can be challenging to interpret their spatial distribution. In such cases, highlighting individual clusters can provide more clarity.

We can highlight specific clusters by using the `CellsByIdentities` function to select bins belonging to particular clusters. Here, we highlight clusters 16 and 8:

```{r}
#| label: clustering_8

cluster_bins = CellsByIdentities(sc, idents=c(16, 8))
cluster_bins[["NA"]] = NULL

SpatialDimPlot(sc, cells.highlight=cluster_bins, facet.highlight=TRUE, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

::: {.callout-tip}
## Recommendations

* Clustering  
  * Test different resolution values to find the best clustering solution for your data  
* UMAP  
  * UMAP "cloud" sizes and the distance between them may not be meaningful since the method has a local notion of distance
  * Helpful explanation on YouTube [here](https://www.youtube.com/watch?v=eN0wFzBA4Sc)
  * Helpful documentation and option to explore [here](https://pair-code.github.io/understanding-umap/)  
* Keep in mind that this represents only a portion of the entire dataset, and the full dataset may reveal additional insights
* Take your time. In scRNA-seq analysis, this is perhaps the most time-consuming step of the basic analysis
:::

::: {.callout-note}
## Question   
* How many clusters do we have?    
* What can we already say about the clusters we have now?   
:::

# Cluster annotation

What cell types correspond to the clusters? To identify the cell types corresponding to the clusters, we typically follow these steps:

* **Cluster marker genes**: Use differential gene expression analysis to find genes that are specifically expressed in each cluster. These can serve as markers for the corresponding cell types.
* **Known marker genes**: Visualize the expression of known cell-type markers on the UMAP to help associate clusters with specific cell types.
* **Mapping a reference dataset**: Use external datasets to map cell-type labels onto your data, enhancing the accuracy of your cell-type predictions.

By using these strategies, you can correlate the clusters with biological cell types and better understand the cell composition of your dataset.

## Cluster marker genes

One of the first steps in identifying the cell types of each cluster is to determine cluster-specific marker genes. These are genes that are significantly up- or down-regulated in one cluster compared to all other clusters, and they can be used to characterize the biological identity of the cells in each cluster. 

A good clustering of cells typically results in good marker genes. Hence, if you cannot find good marker genes you may need to go back to the start of the workflow and adapt your parameters. 

Resulting *p*-values are adjusted using the Bonferroni method. However, beware that *p*-values are likely inflated, since both clusters and marker genes were determined based on the same gene expression data, and there ought to be gene expression differences by design. Nevertheless, *p*-values can be used to sort and prioritize marker genes. 

You can use Seurat `FindMarkers` function to identify differentially expressed genes between clusters:

```{r}
#| label: clusterannot_1

markers = FindAllMarkers(object=sc,
                         test.use="wilcox",
                         layer="data",
                         only.pos=FALSE,
                         max.cells.per.ident=1000)
```

Let us now extract and visualize the top 3 marker genes for each cluster based on the adjusted p-value and log2 foldchange: 

```{r}
#| label: clusterannot_2

# Solution
markers_top = markers %>% 
  dplyr::group_by(cluster) %>% 
  dplyr::arrange(p_val_adj, avg_log2FC) %>% 
  dplyr::slice_head(n=3) %>% 
  dplyr::ungroup() %>% 
  as.data.frame()

gt::gt(markers_top) %>% 
  gt::tab_options(container.height=450)
```

</br>

Good marker genes are highly and possibly even only expressed in one cluster as compared to all other clusters. However, sometimes marker genes are also expressed in other clusters, or are declared as marker genes in these clusters, for example cell lineage markers that are shared by different cell sub types. To evaluate marker genes, it is essential to visualize their expression patterns.

```{r}
#| label: clusterannot_3
#| fig-height: 8
#| fig-width: 12

DotPlot(sc, features=markers_top$gene %>% unique()) +
  viridis::scale_color_viridis() + 
  ylab("Cluster") + xlab("") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=.5),
        legend.position="bottom") + 
  guides(size=guide_legend(order=1, title="Pct expressed"), color=guide_colorbar(title="Scaled Expression")) + 
  ggtitle("Top markers per cluster (expression scaled)")

DotPlot(sc, features=markers_top$gene %>% unique(), scale=FALSE) + 
  viridis::scale_color_viridis() + 
  ylab("Cluster") + xlab("") + 
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=.5),
        legend.position="bottom") + 
  guides(size=guide_legend(order=1, title="Pct expressed"), color=guide_colorbar(title="Average Expression")) +
  ggtitle("Top markers per cluster (expression unscaled)")

```

::: {.callout-note}
## Assignment

Take a good look at the dot plot. Which clusters do / do not have good marker genes? 
:::

## Functional enrichment analysis

We can use the identified cluster marker genes to perform functional enrichment analysis. This helps us infer the potential biological identity or function of each cluster. For simplicity, we will use the online tool [Enrichr](https://maayanlab.cloud/Enrichr/) to perform this analysis. 

::: {.callout-note}
## Assignment

Try to find the identity of one cluster! 
:::

## Plotting known marker genes

To further explore the results and visualize gene expression for known marker genes across different clusters, we can use various plotting functions.

A **violin plot** allows us to visualize the distribution of gene expression across clusters. For example, we can plot the expression of genes Acta2 and Apoe:

```{r}
#| label: plotting_1

VlnPlot(sc, features=c("Acta2", "Apoe"), pt.size=0, ncol=1) + NoLegend()
```

We can also visualize the gene expression directly on top of the **UMAP plot**. This will show the expression of genes such as Acta2 and Apoe across all cells in the low-dimensional UMAP space:

```{r}
#| label: plotting_2

FeaturePlot(sc, features=c("Acta2", "Apoe"))
```

Since we are working with spatial data, you can visualize gene expression in the **spatial context**, showing where the genes are expressed on the tissue section:

```{r}
#| label: plotting_3

SpatialFeaturePlot(sc, features=c("Acta2", "Apoe"))
```

A **dot plot** allows for the visualization of gene expression across multiple clusters for several genes. We have already introduced the dot plot for exploring marker gene expression. To avoid redundancy, we will not revisit it in this section.

For a more detailed look, we can create a **heatmap** to visualize the expression of the same genes in a subset of bins (10000). This allows for a more focused analysis of gene expression patterns across specific clusters.

```{r}
#| label: plotting_5

set.seed(1)
cluster_bins = Cells(sc) %>% 
  sample(10000)

DoHeatmap(sc, features=c("Hap1", "Nap1l5", "Gaa", "Pcp4", "Prkcd", "Rora", "Rgs5", "Itm2a", "Itm2a"), 
          cells=cluster_bins,
          group.colors=cal_pal50, 
          label=FALSE) + 
  scale_fill_viridis() +
  guides(colour="none")
```

```{r}
#| label: rm_1

# Remove since not used anymore and we need the memory.
rm(counts, data, scale_data, umap)

# R will automatically clear the memory of freed objects whenever it needs more space.
# But in our experience it is sometimes better to explicitly tell R to do this - especially when working with big objects.
gc()
```

::: {.callout-note}
## Assignment
Visualize cluster marker genes and known marker genes on the UMAP and in spatial context, and identify at least one cell type from it. 
:::

# Spatial clustering and domains

So far, we have explored the **fundamentals of analyzing spatial (and single-cell) transcriptomic data** using Seurat. The workflow introduced above serves is a good starting point.

However, a key limitation of this approach is that it treats each spatial bin independently, without considering its physical context within the tissue. Spatial analysis methods aim to address this by incorporating neighborhood information—enhancing biological interpretation and robustness. Several steps in our basic workflow can be extended to include this spatial context.

## What is BANKSY?

[BANKSY](https://github.com/prabhakarlab/Banksy) is a computational method specifically designed for spatial transcriptomics analysis. By integrating information from neighboring bins, BANKSY can reduce noise in gene expression data, distinguish between different cell types based on spatial context, and identify spatial domains. 

BANKSY represents each cell or bin not only by its own transcriptomic profile but also by the average expression of its local neighborhood. This dual representation captures both intrinsic cellular identity and microenvironmental context. The degree to which neighborhood information is incorporated is controlled by the lambda parameter:  

* Lower values (e.g., **lambda = 0.2**) emphasize immediate neighbors — useful for **cell typing**  
* Higher values (e.g., **lambda = 0.8**) incorporate broader spatial context — useful for **domain detection**  

Although BANKSY is a standalone tool with its own framework, it can be integrated into Seurat workflows using the `RunBanksy` function from the `SeuratWrappers` package. This allows users to apply BANKSY directly to Seurat objects.

In summary, BANKSY leverages the principle that a cell’s identity is shaped not only by its own gene expression but also by its surrounding environment. By adjusting a single hyperparameter, it provides flexibility to shift focus from cellular identity to higher-order tissue organization.

## Improve clustering with BANKSY

BANKSY can serve as an alternative to the default clustering approach we used earlier. In this step, we apply BANKSY with a low lambda value (0.2) to focus on local neighborhood information, and set the number of neighbors (k_geom) to 15.

**Note:** This step can be time- and memory-intensive.

```{r}
#| label: spatial_1

sc = RunBanksy(sc,
               assay="RNA.008um", assay_name="BANKSY.008um",
               features="variable",
               lambda=0.2, k_geom=15,
               verbose=TRUE)

# Set it as default
DefaultAssay(sc) = "BANKSY.008um"

gc()
```

At this point, we have created a new assay `BANKSY.008um`, containing the BANKSY-transformed data, and have set it as the default.

**⚠️ Important**: BANKSY fills the `scale.data` layer. Therefore do not call `ScaleData` on the BANKSY assay as this negates the effects of lambda. 

```{r}
#| label: spatial_2

sc
```

Next, we apply PCA, clustering, and UMAP using the BANKSY assay. We use the first 15 PCs and set a clustering resolution of 0.5, though these values can and should be adjusted depending on your dataset.

```{r}
#| label: spatial_3

sc = RunPCA(sc, reduction.name="banksy_pca.008um", features=rownames(sc[["BANKSY.008um"]]), npcs=30, nfeatures.print=5)
sc = FindNeighbors(sc, reduction="banksy_pca.008um", dims=1:30)
sc = FindClusters(sc, resolution=0.5, algorithm="leiden")
sc = RunUMAP(sc, reduction="banksy_pca.008um", reduction.name="banksy_umap.008um", dims=1:30, return.model=TRUE)

sc$banksy_clusters.008um = sc$seurat_clusters
DefaultAssay(sc) = "RNA.008um"
```

Here we compare the results of default **Seurat clustering versus BANKSY clustering**, first using UMAP plots:

```{r}
#| label: spatial_4

p1 = DimPlot(sc, reduction="umap.008um", label=TRUE, group.by="seurat_clusters.008um") + NoLegend() + ggtitle("Seurat clustering")
p2 = DimPlot(sc, reduction="banksy_umap.008um", label=TRUE, group.by="banksy_clusters.008um") + NoLegend() + ggtitle("BANKSY clustering")
p1 | p2
```

And as spatial plots:

```{r}
#| label: spatial_5

p1 = SpatialDimPlot(sc, group.by="seurat_clusters.008um") + NoLegend() + ggtitle("Seurat") + scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sc, group.by="banksy_clusters.008um") + NoLegend() + ggtitle("BANKSY") + scale_fill_manual(values=cal_pal50)
p1 | p2
```

::: {.callout-tip}
## Recommendations
BANKSY does not automatically produce better results. Always evaluate both clustering outputs in the context of your biological question and data quality.
:::

## Identifying spatial domains with BANKSY

In addition to improving clustering, BANKSY can be tuned to detect larger-scale tissue structures, often referred to as spatial domains. By increasing the `lambda` parameter and the number of neighbors (`k_geom`), BANKSY incorporates more spatial context and captures broader patterns of gene expression across the tissue.

In the following example, we set `lambda=0.8` and `k_geom=50` to include more neighboring bins in the analysis.

**Note:** We first remove the BANKSY assay from the previous run to conserve memory. This step is optional but will save us some memory resources.

```{r}
#| label: spatial_6

DefaultAssay(sc) = "RNA.008um"
sc = RunBanksy(sc,
               assay="RNA.008um", assay_name="BANKSY.008um",
               features="variable",
               lambda=0.8, k_geom=50,
               verbose=TRUE)

# Set it as default
DefaultAssay(sc) = "BANKSY.008um"

gc()
```

As before, we perform PCA, clustering, and UMAP on the BANKSY assay. We use the first 10 PCs and a clustering resolution of 0.5, but these values should again be adjusted depending on your dataset:

```{r}
#| label: spatial_7

sc = RunPCA(sc, reduction.name="banksy_pca.008um", features=rownames(sc[["BANKSY.008um"]]), npcs=30, nfeatures.print=5)
sc = FindNeighbors(sc, reduction="banksy_pca.008um", dims=1:30)
sc = FindClusters(sc, resolution=0.5, algorithm="leiden")
sc$banksy_domains.008um = sc$seurat_clusters
```

If your clustering results look similar to those from the previous BANKSY run (with `lambda=0.2`), this could indicate that the dominant tissue structures are already captured at a local level. We encourage you to systematically explore different parameter settings for `lambda`, `k_geom`, and `resolution` to assess their impact on clustering outcomes and spatial domain resolution.

Since this BANKSY run is also complete, we again remove the assay and PCA reduction to free up memory:

```{r}
#| label: spatial_8

# Remove BANKSY assay and pca since not used anymore and we need the memory.
DefaultAssay(sc) = "RNA.008um"
sc[["BANKSY.008um"]] = NULL
sc[["banksy_pca.008um"]] = NULL
gc()
```

::: {.callout-tip}
## Recommended reading

If you want to learn more about BANKSY, we find these pages helpful: 

* https://github.com/satijalab/seurat-wrappers/blob/master/docs/banksy.md  
* https://github.com/prabhakarlab/Banksy?tab=readme-ov-file  

:::

# Cell type annotation by deconvolution

Spatial transcriptomics data often require deconvolution to **resolve the cellular composition** of individual spatial units (bins). This section guides you through the process of estimating cell type compositions in Visium HD data using the RCTD method from the `spacexr` package.

## What is deconvolution?

In spatial transcriptomics, such as 10x Visium HD, each bin may contain zero, one, or multiple cells, depending on the resolution, cell size, and local cell density. As a result, we cannot assume that each bin corresponds to a single cell. To address this, deconvolution methods are used to estimate the proportion of different cell types within each bin.

These methods also often incorporate spatial information (i.e., neighborhood relationships between bins) to improve accuracy.

One such method is **Robust Cell Type Decomposition (RCTD)**, implemented in the [`spacexr`](https://github.com/dmcable/spacexr) package. RCTD learns gene expression profiles of cell types from a **single-cell reference dataset** and uses these profiles to deconvolve spatial bins into estimated cell type compositions.

For this tutorial, we use a preprocessed reference derived from the [Allen Brain atlas](https://portal.brain-map.org/) single-cell dataset, filtered to include 200,000 cells with rare cell types removed. We will annotate only the cortex region of the Visium HD dataset.

## Subset the cortex region

We first extract the cortex region using [pre-defined coordinates](https://www.dropbox.com/scl/fi/qbs3j1alq33f0qz892ub3/cortex-hippocampus_coordinates.csv?rlkey=lsxglb15jhjdrircy9lb6n0rd&dl=0) from a CSV file and convert them into a segmentation object with `CreateSegmentation`. Next we use the `Overlay` function to identify all bins in our spatial dataset that fall into the cortex region: 

```{r}
#| label: annot_1

cortex_coordinates = read.csv("datasets/cortex_coordinates.csv")
cortex_coordinates = CreateSegmentation(cortex_coordinates)

sc[["cortex"]] = Overlay(sc[["slice1.008um"]], cortex_coordinates)
DefaultAssay(sc[["cortex"]]) = ""
SpatialDimPlot(sc, images="cortex", cols=cal_pal50) + NoLegend() + scale_fill_manual(values=cal_pal50)
```

Next, we create a Seurat object that only includes the bins that fall within the cortex region:

```{r}
#| label: annot_2

cortex_bins = Cells(sc[["cortex"]])
cortex = subset(sc, cells=cortex_bins)
cortex[["sketch"]] = NULL
cortex[["pca.sketch"]] = NULL
cortex[["umap.sketch"]] = NULL
cortex[["pca.008um"]] = NULL
cortex[["umap.008um"]] = NULL
cortex[["banksy_umap.008um"]] = NULL
cortex
```

To make the analysis computationally manageable, we sketch the dataset down to 50,000 bins for this tutorial, then perform feature selection, data scaling and PCA:

```{r}
#| label: annot_3

# Sketch
cortex = FindVariableFeatures(cortex, nfeatures=1000)
cortex = SketchData(
  object = cortex,
  ncells = 50000,
  method = "LeverageScore",
  sketched.assay = "sketch",
  over.write = TRUE
)
# Feature selection
cortex = FindVariableFeatures(cortex, nfeatures=1000)

# Scale data
cortex = ScaleData(cortex, features=VariableFeatures(cortex))

# PCA
cortex = RunPCA(cortex, reduction.name="pca.sketch", features=VariableFeatures(cortex), npcs=50, nfeatures.print=5)
```

We now prepare the `SpatialRNA` object required by `spacexr`:

```{r}
#| label: annot_4

# Counts
counts = GetAssayData(cortex, assay="sketch", layer="counts")

# Coordinates
bins_sketch = Cells(cortex[["sketch"]])
coords = GetTissueCoordinates(cortex)[bins_sketch, 1:2]

# Total counts
total_counts = colSums(counts)

# Create spacexr SpatialRNA object
query = spacexr::SpatialRNA(coords, counts, total_counts)
```

## Load and prepare the reference dataset

We begin by loading the [Allen Brain single-cell reference dataset](https://www.dropbox.com/scl/fi/r1mixf4eof2cot891n215/allen_scRNAseq_ref.Rds?rlkey=ynr6s6wu1efqsjsu3h40vitt7&dl=0), which has been saved as a Seurat object:

```{r}
#| label: annot_5

ref = readRDS("datasets/allen_scRNAseq_ref.Rds")
ref
```

We use the `subclass_label` column for cell type annotations:

```{r}
#| label: annot_6

ref[[]] %>% dplyr::select(subclass_label) %>% head(10)
table(ref$subclass_label)
```

We convert this Seurat object into a `spacexr` Reference object:

```{r}
#| label: annot_7

# Counts
counts = GetAssayData(ref, assay="RNA", layer="counts")

# Cell type labels
cell_types = as.factor(ref$subclass_label)
levels(cell_types) = gsub("/", "-", levels(cell_types))
cell_types = droplevels(cell_types)

# Total counts
total_counts = ref$nCount_RNA

# Create Reference object
ref = spacexr::Reference(counts, cell_types, total_counts, n_max_cells=500)

# Remove since not needed
rm(coords, counts, cortex_coordinates)
gc()
```

## Run RCTD

We are now ready to run RCTD. However, since this step is time-consuming, we provide the results precomputed and saved in the file `datasets/RCTD.Rds`. For completeness, here is how you would normally run the algorithm:

```{r}
#| label: annot_8

# This will take five hours
#
#RCTD = create.RCTD(query, ref, max_cores=12)
#RCTD = run.RCTD(RCTD, doublet_mode = "doublet")
#saveRDS(RCTD, "datasets/RCTD.Rds")
#gc()
```

We simply load the results:

```{r}
#| label: annot_9

RCTD = readRDS("datasets/RCTD.Rds")
RCTD_results = RCTD@results$results_df
head(RCTD_results)
```

The `results_df` contains the main output of the deconvolution. Key columns include:  
* `spot_class`: classification of each bin ("singlet", "doublet_certain", "doublet_uncertain", "reject")  
* `first_type`: predicted identity of the first cell type  
* `second_type`: only populated for doublets

We now add these predictions to the bin metadata of the cortex object:

```{r}
#| label: annot_10

# Add to cortex object
RCTD_results = RCTD_results[, c("spot_class", "first_type", "scond_type")]
colnames(RCTD_results) = c("doublet", "first_cell_type", "second_cell_type")
cortex = AddMetaData(cortex, metadata=RCTD_results)

# Replace NA (not available) with "unknown"
cortex$doublet = as.character(cortex$doublet)
cortex$doublet[is.na(cortex$doublet)] = "unknown"
cortex$doublet = factor(cortex$doublet)

cortex$first_cell_type = as.character(cortex$first_cell_type)
cortex$first_cell_type[is.na(cortex$first_cell_type)] = "Unknown"
cortex$first_cell_type = factor(cortex$first_cell_type)

cortex$second_cell_type = as.character(cortex$second_cell_type)
cortex$second_cell_type[is.na(cortex$second_cell_type)] = "Unknown"
cortex$second_cell_type = factor(cortex$second_cell_type)
```

## Project back and transfer results

We now project the RCTD results from the sketch cortex dataset to the full cortex dataset. This is similar to the projection of the clustering and UMAP results we did before:

```{r}
#| label: annot_11

DefaultAssay(cortex) = "RNA.008um"

cortex = ProjectData(cortex,
                 sketched.assay="sketch", assay="RNA.008um", 
                 sketched.reduction="pca.sketch", full.reduction="pca.008um", 
                 refdata=list(doublet.008um="doublet",
                              first_cell_type.008um="first_cell_type",
                              second_cell_type.008um="second_cell_type"),
                 dims=1:30)
```

Next, we include the projected predictions in the original brain dataset (`sc`):

```{r}
#| label: annot_12

# We will the columns with "unknown" and then set the values for all cells of the cortex
cortex_bins = rownames(cortex[[]])
sc$doublet.008um = "unknown"
sc$doublet.008um[cortex_bins] = cortex$doublet.008um[cortex_bins]
sc$doublet.008um = factor(sc$doublet.008um)

sc$first_cell_type.008um = "Unknown"
sc$first_cell_type.008um[cortex_bins] = cortex$first_cell_type.008um[cortex_bins]
sc$first_cell_type.008um = factor(sc$first_cell_type.008um)

sc$second_cell_type.008um = "Unknown"
sc$second_cell_type.008um[cortex_bins] = cortex$second_cell_type.008um[cortex_bins]
sc$second_cell_type.008um = factor(sc$second_cell_type.008um)
```

## Visualize the results

We can now visualize cell type predictions. For example, here we highlight three predicted excitatory neuron layers (typically labeled as L2/3, L4/5, and L5) on the spatial plot:
:
```{r}
#| label: annot_13

Idents(sc) = "first_cell_type.008um"

layered_excitatory_neurons = c("L2-3 IT CTX", "L4-5 IT CTX", "L5 IT CTX")
layered_excitatory_bins = CellsByIdentities(sc, idents=layered_excitatory_neurons)
layered_excitatory_bins[["NA"]] = NULL

SpatialDimPlot(sc, cells.highlight=layered_excitatory_bins, facet.highlight=TRUE, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```

## Annotate clusters and domains

Using the predicted cell types, we can now try to annotate our clusters and domains. Keep in mind that predictions were only generated for a subset of the dataset, so results may not apply to all clusters.

We plot the distribution of predicted cell types for the `seurat_clusters` and `banksy_clusters`:

```{r}
#| label: annot_14

# Include cell types with at least 100 bins annotated
# Do not include bins with "Unknown" cell type
bins_per_cell_type = table(sc$first_cell_type.008um)
cell_types_to_include = which(bins_per_cell_type >= 100) %>% names()
cell_types_to_include = cell_types_to_include[cell_types_to_include != "Unknown"]

# Count cell types per cluster
cell_type_cluster_counts = sc[[]] %>% 
         dplyr::filter(first_cell_type.008um %in% cell_types_to_include) %>%
         dplyr::count(first_cell_type.008um, seurat_clusters.008um)

# Plot distribution
ggplot(cell_type_cluster_counts,
       aes(x=seurat_clusters.008um, y=n, fill=first_cell_type.008um)) +
  geom_bar(stat = "identity", position = "fill") +
  ylab("# of bins") +
  ggtitle(paste0("Distribution of Cell Types across seurat clusters")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

```{r}
#| label: annot_15

# Count cell types per cluster
cell_type_cluster_counts = sc[[]] %>% 
         dplyr::filter(first_cell_type.008um %in% cell_types_to_include) %>%
         dplyr::count(first_cell_type.008um, banksy_clusters.008um)

# Plot distribution
ggplot(cell_type_cluster_counts,
       aes(x=banksy_clusters.008um, y=n, fill=first_cell_type.008um)) +
  geom_bar(stat = "identity", position = "fill") +
  ylab("# of bins") +
  ggtitle(paste0("Distribution of Cell Types across banksy clusters")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

We observe that several **clusters** contain multiple predicted cell types, indicating that clustering performance should still be improved. However, it is also evident that many **bins** may contain more than one cell type, which inherently complicates the clustering process.

Annotation may work better for larger structures such as the `banksy_domains`. Here we have a look some of the excitatory neurons that we identified in the previous section and try to find protein domains:

```{r}
#| label: annot_16

cell_type_domain_counts = sc[[]] %>%
  dplyr::filter(first_cell_type.008um %in% layered_excitatory_neurons) %>%
  dplyr::count(first_cell_type.008um, banksy_domains.008um)

ggplot(cell_type_domain_counts,
       aes(x=first_cell_type.008um, y=n, fill=banksy_domains.008um)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = ifelse(n>50, as.character(first_cell_type.008um), "")),
                position = position_stack(vjust = 0.5), size = 3) +
  ylab("# of bins") +
  ggtitle(paste0("Protein Domains with selected excitatory neurons")) +
  theme_minimal()
```

Here we can identify several BANKSY domains as excitatory neuron layers.

::: {.callout-note}
## Assignment

Find marker genes for the identified BANKSY domains, and suggest the identify of at least 1 domain
:::

# Export results to Loupe

In a previous session, we introduced the Loupe Browser as a convenient tool for exploring spatial transcriptomics data. In this section, we will export the results of our analysis as CSV files, enabling their import and further exploration in Loupe.

```{r}
#| label: loupe_export

# Only for the 8 um bins
bins_to_export = Cells(sc[["RNA.008um"]])

# Bin metadata
metadata_to_export = sc[[]][bins_to_export, ] %>%
  dplyr::select(orig.ident, seurat_clusters.008um) %>%
  tibble::rownames_to_column("barcode")

write.csv(metadata_to_export, "datasets/exported_bin_metadata.csv", row.names=FALSE)

# UMAP
umap_to_export = Embeddings(sc[["umap.008um"]])[bins_to_export, ] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Barcode")
write.csv(umap_to_export, "datasets/exported_umap.csv", row.names=FALSE)
```

Information about importing results into Loupe can be found in the [Loupe tutorial](https://www.10xgenomics.com/support/software/loupe-browser/latest/tutorials/introduction/lb-sc-interface-and-navigation).

# Session info

To enhance reproducibility and facilitate the sharing of your analysis, it is good practice to include information about the R session and the packages used:

```{r}
#| label: session_info

sessioninfo::session_info()
```

# Useful resources

- Best practices:
  - [Single-cell best practices](https://www.sc-best-practices.org/preamble.html)
  - [Orchestrating Single-Cell Analysis with Bioconductor
](https://bioconductor.org/books/release/OSCA/)
  - [Orchestrating Spatial Transcriptomics Analysis with Bioconductor
](https://lmweber.org/OSTA/)
- Seurat:
  - [Essential commands](https://satijalab.org/seurat/articles/essential_commands)
  - [Basic Single-cell Analysis Vignette](https://satijalab.org/seurat/articles/pbmc3k_tutorial)
  - [Seurat Visium Analysis Vignette](https://satijalab.org/seurat/articles/spatial_vignette)
  - [Seurat Visium HD Analysis Vignette](https://satijalab.org/seurat/articles/visiumhd_analysis_vignette)
- Tools:
  - [Spaceranger](https://www.10xgenomics.com/support/software/space-ranger/latest)
  - [Loupe Browser](https://www.10xgenomics.com/support/software/loupe-browser/latest)
  - [Spotsweeper](https://github.com/MicTott/SpotSweeper)
  - [banksy](https://github.com/prabhakarlab/Banksy)


